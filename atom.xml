<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Timmy的軟韌體開發筆記</title>
  
  <subtitle>累積經驗，分享經驗</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://m033010041.github.io/"/>
  <updated>2018-11-21T09:10:38.408Z</updated>
  <id>https://m033010041.github.io/</id>
  
  <author>
    <name>Timmy Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[讀書心得] The Linux Programming Interface chapter 19：檔案監控事件</title>
    <link href="https://m033010041.github.io/2018/11/21/TLPI-inotify/"/>
    <id>https://m033010041.github.io/2018/11/21/TLPI-inotify/</id>
    <published>2018-11-21T01:59:28.127Z</published>
    <updated>2018-11-21T09:10:38.408Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inotify_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>wd;</span><br><span class="line">    <span class="keyword">uint32_t</span>mask;</span><br><span class="line">    <span class="keyword">uint32_t</span>cookie;</span><br><span class="line">    <span class="keyword">uint32_t</span>len;</span><br><span class="line">    <span class="keyword">char</span>name[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這一章節，主要是在了解應用程式為了知道監控物件 (object) 發生了哪些事件，需要能夠監視檔案以及目錄，像是說</p><ul><li>圖形化的檔案管理程式可以知道檔案何時從目前的正在顯示的目錄中新增或是刪除</li><li>一個守護程式 (又稱常駐程式, daemon) 可能會監視一個組態檔案觀察是否該檔案是否有被更動過</li></ul><p>從 kernel <code>v2.6.13</code> 開始，Linux 提供了 inotify 機制，接受應用程式監控檔案與目錄事件<br>inotify 機制取代了舊有的 dnotify 機制，最後會介紹 dnotify 並且解釋 inotify 為何比較好</p><h2 id="19-1-概觀"><a href="#19-1-概觀" class="headerlink" title="19.1 概觀"></a>19.1 概觀</h2><p>使用 inotify API 步驟</p><ol><li>先使用 <code>inotify_init()</code> 建立一個 inotify instance，之後會回傳一個檔案描述符 (file descriptor)</li><li>針對核心有興趣的檔案，使用 <code>inotify_add_watch()</code> 新增項目到所建立的 inotify instance 中，每個項目都有一個路徑名稱與監控事件集合，透過函式內的位元遮罩 (bit mask) 進行處理</li><li><code>inotify_add_watch()</code> 針對每一個監控項目，回傳一個監控描述符 (watch descriptor, wd)</li><li>透過 <code>read()</code> 操作讀取 inotify instance，每次成功 <code>read()</code> 後都會回傳一個以上的 <code>inotify_event</code> 結構</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inotify_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>wd;</span><br><span class="line">    <span class="keyword">uint32_t</span>mask;</span><br><span class="line">    <span class="keyword">uint32_t</span>cookie;</span><br><span class="line">    <span class="keyword">uint32_t</span>len;</span><br><span class="line">    <span class="keyword">char</span>name[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="19-2-inotify-API"><a href="#19-2-inotify-API" class="headerlink" title="19.2 inotify API"></a>19.2 inotify API</h2><h3 id="新增-inotify-instance"><a href="#新增-inotify-instance" class="headerlink" title="新增 inotify instance"></a>新增 inotify instance</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/inotify.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns file descriptor on success, or -1 on error */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inotify_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>回傳的 file descriptor 可以對於一個 inotify instance 進行操作</p><h3 id="新增監看項目，回傳監看描述符"><a href="#新增監看項目，回傳監看描述符" class="headerlink" title="新增監看項目，回傳監看描述符"></a>新增監看項目，回傳監看描述符</h3><p>根據上方的步驟，接下來我們會執行<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/inotify.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns watch descriptor (wd) on success, or -1 on error */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inotify_add_watch</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uint32_t</span> mask)</span></span>;</span><br></pre></td></tr></table></figure></p><p>此項目會對 fd 所參考的 inotify instance 新增一個監看項目，每一個監看項目有</p><ul><li>監看路徑</li><li>監看事件集合 (bit mask)<br><img src="/2018/11/21/TLPI-inotify/19_1.png" width="50%"></li><li><strong>若 pathname 為空</strong>，則 <code>inotify_add_watch()</code> 會建立一個新的監看項目並回傳一個非負值的 watch descriptor</li></ul><h3 id="移除監看項目"><a href="#移除監看項目" class="headerlink" title="移除監看項目"></a>移除監看項目</h3><p>若要移除 inotify instance 中的監看項目，會使用系統呼叫：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/inotify.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns 0 on success, or -1 on error */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inotify_rm_watch</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> wd)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="19-3-inotify-Events"><a href="#19-3-inotify-Events" class="headerlink" title="19.3 inotify Events"></a>19.3 inotify Events</h2><p>下圖為 inotify 事件列表，可以透過 <code>inotify_add_watch()</code> 中的 mask 參數識別要監視的 pathname 事件集合</p><ul><li>當權限、所有者、連結計數、擴充屬性、使用者 ID 或是群組 ID 等 metadata 資料改變時，會發生 <code>IN_ATTRIB</code> 事件</li><li>若目標監視刪除時，會發生 <code>IN_DELETE_SELF</code> 事件，若受監視是 <strong>目錄</strong> 且目錄中的其中一個檔案被刪除時，會發生 <code>IN_DELETE</code> 事件</li><li>若受監視的物件重新命名時，會發生 <code>IN_MOVE_SELF</code> 事件，若 <strong>監視目錄</strong> 中的其中一個物件重新命名時，會發生 <code>IN_MOVE_FROM</code> 與 <code>IN_MOVE_TO</code> 事件</li></ul><h2 id="19-4-Read-inotify-Event"><a href="#19-4-Read-inotify-Event" class="headerlink" title="19.4 Read inotify Event"></a>19.4 Read inotify Event</h2><p>使用 <code>read()</code> 進行讀取事件動作<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Max_Event10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_LEN(Max_Event * ((sizeof(struct inotify_event) + NAME_MAX + 1)))</span></span><br><span class="line"><span class="keyword">int</span> numRead;</span><br><span class="line"><span class="keyword">int</span> inotifyFd; <span class="comment">//From inotify_init()</span></span><br><span class="line"><span class="keyword">char</span> buf[BUF_LEN];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* In function */</span></span><br><span class="line">numRead = read(inotifyFd, buf, BUF_LEN);</span><br></pre></td></tr></table></figure></p><p>讀取一次的量為各事件發生時的數目<br>事件發生數目為 <code>numRead / (BUF_LEN/Max_Event)</code></p><p><img src="/2018/11/21/TLPI-inotify/19_2.png" width="50%"><br><code>inotify_add_watch()</code> 的 mask 可以帶入 <code>sys/inotify.h</code> 中的 <code>IN_ALL_EVNET</code> ，定義如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN_ALL_EVENTS(IN_ACCESS | IN_MODIFY | IN_ATTRIB | IN_CLOSE_WRITE | \</span></span><br><span class="line"> IN_CLOSE_NOWRITE | IN_OPEN | IN_MOVED_FROM | \</span><br><span class="line"> IN_MOVED_TO | IN_DELETE | IN_CREATE | IN_DELETE_SELF)</span><br></pre></td></tr></table></figure><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><ol><li>add file / directory</li><li>modify file</li><li>using <code>echo hello &gt; file.txt</code></li><li>rename file</li><li>move file to other place</li><li><code>IN_ONESHOT</code> 使用觀察 <code>IN_IGNORED</code> 的狀況</li><li>若監視檔案移動到別的地方了，wd 中的 pathname 會不會更動？</li></ol><h2 id="19-5-佇列限制與-proc-檔案"><a href="#19-5-佇列限制與-proc-檔案" class="headerlink" title="19.5 佇列限制與 /proc 檔案"></a>19.5 佇列限制與 /proc 檔案</h2><p>在 linux kernel configuration 中要啟用 inotify，必須先開啟 menuconfig</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Symbol: INOTIFY_USER [=y]</span><br><span class="line">Type  : boolean Prompt:</span><br><span class="line">Inotify support for userspace</span><br><span class="line">  Defined at fs/notify/inotify/Kconfig:1</span><br><span class="line">  Location:</span><br><span class="line">    -&gt; File systems</span><br><span class="line">  Selects: ANON_INODES [=y] &amp;&amp; FSNOTIFY [=y]</span><br></pre></td></tr></table></figure><p>之後可以在 <code>/proc/sys/fs/inotify/</code> 中設定 inotify 機制的操作組態，此設定要為高權限使用者<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls -l /proc/sys/fs/inotify/</span><br><span class="line"></span><br><span class="line">-rw-r--r--1root0 Nov 21 14:58 max_queued_events</span><br><span class="line">-rw-r--r--1root0 Nov 21 14:58 max_user_instances</span><br><span class="line">-rw-r--r--1root0 Nov 21 14:58 max_user_watches</span><br></pre></td></tr></table></figure></p><ul><li><code>max_queued_events</code>: <font color="#FF0000">default 16384</font><ul><li>當呼叫 <code>inotify_init()</code> 時，這個值是設定新的 inotify instance 數目上限，若超過的話會產生 <code>IN_Q_OVERFLOW</code> 事件，wd return -1</li></ul></li><li><code>max_user_instances</code>: <font color="#FF0000">default 128</font><ul><li>真實使用者可以建立的 inotify instance 數目</li></ul></li><li><code>max_user_watches</code>: <font color="#FF0000">default 8192</font><ul><li>真實使用者可以建立的監看項目數量限制</li></ul></li><li>以上都可以進行設定</li></ul><h2 id="19-6-舊版本的系統監視檔案事件：dnotify"><a href="#19-6-舊版本的系統監視檔案事件：dnotify" class="headerlink" title="19.6 舊版本的系統監視檔案事件：dnotify"></a>19.6 舊版本的系統監視檔案事件：dnotify</h2><p>從 Linux kernel <code>v2.4</code> 之後支援，之後被 inotify 所取代，因為有許多限制：</p><ul><li>dnotify 是透過 signal 傳送事件通知，而 inotify 沒有使用訊號</li><li>dnotify 監視的單位是一個 <strong>目錄</strong> ，而 inotify 則可以用來監視檔案或目錄</li><li>為了監視目錄，dnotify 需要應用程式開啟那個目錄的 fd ，使用 file descriptor 會有兩個問題<ul><li>由於忙碌，所以包含那個目錄的檔案系統都不可以被卸載</li><li>每個目錄都需要 fd ，所以會消耗大量的檔案描述符，但 inotify 沒有使用，所以可以避免這個問題</li></ul></li><li>dnotify 事件資訊沒有 inotify 來得精準</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;inotify_event&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;		wd;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt;	mask;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt;	cookie;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt;	len;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;	name[];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="The Linux Programming Interface" scheme="https://m033010041.github.io/tags/The-Linux-Programming-Interface/"/>
    
      <category term="Linux" scheme="https://m033010041.github.io/tags/Linux/"/>
    
      <category term="讀書心得" scheme="https://m033010041.github.io/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://m033010041.github.io/2018/11/18/hello-world/"/>
    <id>https://m033010041.github.io/2018/11/18/hello-world/</id>
    <published>2018-11-18T15:07:05.659Z</published>
    <updated>2018-11-20T10:38:38.814Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="測試" scheme="https://m033010041.github.io/tags/%E6%B8%AC%E8%A9%A6/"/>
    
  </entry>
  
</feed>
