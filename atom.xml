<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Timmy的軟韌體開發筆記</title>
  
  <subtitle>累積經驗，分享經驗</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://m033010041.github.io/"/>
  <updated>2018-11-21T16:42:57.694Z</updated>
  <id>https://m033010041.github.io/</id>
  
  <author>
    <name>Timmy Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[讀書心得] The Linux Programming Interface 第 19 章：檔案監控事件</title>
    <link href="https://m033010041.github.io/2018/11/21/TLPI-inotify/"/>
    <id>https://m033010041.github.io/2018/11/21/TLPI-inotify/</id>
    <published>2018-11-21T01:59:28.127Z</published>
    <updated>2018-11-21T16:42:57.694Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inotify_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>wd;</span><br><span class="line">    <span class="keyword">uint32_t</span>mask;</span><br><span class="line">    <span class="keyword">uint32_t</span>cookie;</span><br><span class="line">    <span class="keyword">uint32_t</span>len;</span><br><span class="line">    <span class="keyword">char</span>name[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這一章節，主要是在了解應用程式為了知道監控物件 (object) 發生了哪些事件，需要能夠監視檔案以及目錄，像是說</p><ul><li>圖形化的檔案管理程式可以知道檔案何時從目前的正在顯示的目錄中新增或是刪除</li><li>一個守護程式 (又稱常駐程式, daemon) 可能會監視一個組態檔案觀察是否該檔案是否有被更動過</li></ul><p>從 kernel <code>v2.6.13</code> 開始，Linux 提供了 inotify 機制，接受應用程式監控檔案與目錄事件<br>inotify 機制取代了舊有的 dnotify 機制，最後會介紹 dnotify 並且解釋 inotify 為何比較好</p><h2 id="19-1-概觀"><a href="#19-1-概觀" class="headerlink" title="19.1 概觀"></a>19.1 概觀</h2><p>使用 inotify API 步驟</p><ol><li>先使用 <code>inotify_init()</code> 建立一個 inotify instance，之後會回傳一個檔案描述符 (file descriptor)</li><li>針對核心有興趣的檔案，使用 <code>inotify_add_watch()</code> 新增項目到所建立的 inotify instance 中，每個項目都有一個路徑名稱與監控事件集合，透過函式內的位元遮罩 (bit mask) 進行處理</li><li><code>inotify_add_watch()</code> 針對每一個監控項目，回傳一個監控描述符 (watch descriptor, wd)</li><li>透過 <code>read()</code> 操作讀取 inotify instance，每次成功 <code>read()</code> 後都會回傳一個以上的 <code>inotify_event</code> 結構</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inotify_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>wd;</span><br><span class="line">    <span class="keyword">uint32_t</span>mask;</span><br><span class="line">    <span class="keyword">uint32_t</span>cookie;</span><br><span class="line">    <span class="keyword">uint32_t</span>len;</span><br><span class="line">    <span class="keyword">char</span>name[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="19-2-inotify-API"><a href="#19-2-inotify-API" class="headerlink" title="19.2 inotify API"></a>19.2 inotify API</h2><h3 id="新增-inotify-instance"><a href="#新增-inotify-instance" class="headerlink" title="新增 inotify instance"></a>新增 inotify instance</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/inotify.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns file descriptor on success, or -1 on error */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inotify_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>回傳的 file descriptor 可以對於一個 inotify instance 進行操作</p><h3 id="新增監看項目，回傳監看描述符"><a href="#新增監看項目，回傳監看描述符" class="headerlink" title="新增監看項目，回傳監看描述符"></a>新增監看項目，回傳監看描述符</h3><p>根據上方的步驟，接下來我們會執行<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/inotify.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns watch descriptor (wd) on success, or -1 on error */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inotify_add_watch</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uint32_t</span> mask)</span></span>;</span><br></pre></td></tr></table></figure></p><p>此項目會對 fd 所參考的 inotify instance 新增一個監看項目，每一個監看項目有</p><ul><li>監看路徑</li><li>監看事件集合 (bit mask)<br><img src="/2018/11/21/TLPI-inotify/19_1.png" width="70%"></li><li><strong>若 pathname 為空</strong>，則 <code>inotify_add_watch()</code> 會建立一個新的監看項目並回傳一個非負值的 watch descriptor</li></ul><h3 id="移除監看項目"><a href="#移除監看項目" class="headerlink" title="移除監看項目"></a>移除監看項目</h3><p>若要移除 inotify instance 中的監看項目，會使用系統呼叫：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/inotify.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns 0 on success, or -1 on error */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inotify_rm_watch</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> wd)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="19-3-inotify-Events"><a href="#19-3-inotify-Events" class="headerlink" title="19.3 inotify Events"></a>19.3 inotify Events</h2><p>下圖為 inotify 事件列表，可以透過 <code>inotify_add_watch()</code> 中的 mask 參數識別要監視的 pathname 事件集合</p><ul><li>當權限、所有者、連結計數、擴充屬性、使用者 ID 或是群組 ID 等 metadata 資料改變時，會發生 <code>IN_ATTRIB</code> 事件</li><li>若目標監視刪除時，會發生 <code>IN_DELETE_SELF</code> 事件，若受監視是 <strong>目錄</strong> 且目錄中的其中一個檔案被刪除時，會發生 <code>IN_DELETE</code> 事件</li><li>若受監視的物件重新命名時，會發生 <code>IN_MOVE_SELF</code> 事件，若 <strong>監視目錄</strong> 中的其中一個物件重新命名時，會發生 <code>IN_MOVE_FROM</code> 與 <code>IN_MOVE_TO</code> 事件</li></ul><h2 id="19-4-Read-inotify-Event"><a href="#19-4-Read-inotify-Event" class="headerlink" title="19.4 Read inotify Event"></a>19.4 Read inotify Event</h2><p>使用 <code>read()</code> 進行讀取事件動作<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Max_Event10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_LEN(Max_Event * ((sizeof(struct inotify_event) + NAME_MAX + 1)))</span></span><br><span class="line"><span class="keyword">int</span> numRead;</span><br><span class="line"><span class="keyword">int</span> inotifyFd; <span class="comment">//From inotify_init()</span></span><br><span class="line"><span class="keyword">char</span> buf[BUF_LEN];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* In function */</span></span><br><span class="line">numRead = read(inotifyFd, buf, BUF_LEN);</span><br></pre></td></tr></table></figure></p><p>讀取一次的量為各事件發生時的數目<br>事件發生數目為 <code>numRead / (BUF_LEN/Max_Event)</code></p><p><img src="/2018/11/21/TLPI-inotify/19_2.png" width="70%"><br><code>inotify_add_watch()</code> 的 mask 可以帶入 <code>sys/inotify.h</code> 中的 <code>IN_ALL_EVENT</code> ，定義如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN_ALL_EVENTS(IN_ACCESS | IN_MODIFY | IN_ATTRIB | IN_CLOSE_WRITE | \</span></span><br><span class="line"> IN_CLOSE_NOWRITE | IN_OPEN | IN_MOVED_FROM | \</span><br><span class="line"> IN_MOVED_TO | IN_DELETE | IN_CREATE | IN_DELETE_SELF)</span><br></pre></td></tr></table></figure><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><ol><li>add file / directory</li><li>modify file</li><li>using <code>echo hello &gt; file.txt</code></li><li>rename file</li><li>move file to other place</li><li><code>IN_ONESHOT</code> 使用觀察 <code>IN_IGNORED</code> 的狀況</li><li>若監視檔案移動到別的地方了，wd 中的 pathname 會不會更動？</li></ol><h2 id="19-5-佇列限制與-proc-檔案"><a href="#19-5-佇列限制與-proc-檔案" class="headerlink" title="19.5 佇列限制與 /proc 檔案"></a>19.5 佇列限制與 /proc 檔案</h2><p>在 linux kernel configuration 中要啟用 inotify，必須先開啟 menuconfig</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Symbol: INOTIFY_USER [=y]</span><br><span class="line">Type  : boolean Prompt:</span><br><span class="line">Inotify support for userspace</span><br><span class="line">  Defined at fs/notify/inotify/Kconfig:1</span><br><span class="line">  Location:</span><br><span class="line">    -&gt; File systems</span><br><span class="line">  Selects: ANON_INODES [=y] &amp;&amp; FSNOTIFY [=y]</span><br></pre></td></tr></table></figure><p>之後可以在 <code>/proc/sys/fs/inotify/</code> 中設定 inotify 機制的操作組態，此設定要為高權限使用者<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls -l /proc/sys/fs/inotify/</span><br><span class="line"></span><br><span class="line">-rw-r--r--1root0 Nov 21 14:58 max_queued_events</span><br><span class="line">-rw-r--r--1root0 Nov 21 14:58 max_user_instances</span><br><span class="line">-rw-r--r--1root0 Nov 21 14:58 max_user_watches</span><br></pre></td></tr></table></figure></p><ul><li><code>max_queued_events</code>: <font color="#FF0000">default 16384</font><ul><li>當呼叫 <code>inotify_init()</code> 時，這個值是設定新的 inotify instance 數目上限，若超過的話會產生 <code>IN_Q_OVERFLOW</code> 事件，wd return -1</li></ul></li><li><code>max_user_instances</code>: <font color="#FF0000">default 128</font><ul><li>真實使用者可以建立的 inotify instance 數目</li></ul></li><li><code>max_user_watches</code>: <font color="#FF0000">default 8192</font><ul><li>真實使用者可以建立的監看項目數量限制</li></ul></li><li>以上都可以進行設定</li></ul><h2 id="19-6-舊版本的系統監視檔案事件：dnotify"><a href="#19-6-舊版本的系統監視檔案事件：dnotify" class="headerlink" title="19.6 舊版本的系統監視檔案事件：dnotify"></a>19.6 舊版本的系統監視檔案事件：dnotify</h2><p>從 Linux kernel <code>v2.4</code> 之後支援，之後被 inotify 所取代，因為有許多限制：</p><ul><li>dnotify 是透過 signal 傳送事件通知，而 inotify 沒有使用訊號</li><li>dnotify 監視的單位是一個 <strong>目錄</strong> ，而 inotify 則可以用來監視檔案或目錄</li><li>為了監視目錄，dnotify 需要應用程式開啟那個目錄的 fd ，使用 file descriptor 會有兩個問題<ul><li>由於忙碌，所以包含那個目錄的檔案系統都不可以被卸載</li><li>每個目錄都需要 fd ，所以會消耗大量的檔案描述符，但 inotify 沒有使用，所以可以避免這個問題</li></ul></li><li>dnotify 事件資訊沒有 inotify 來得精準</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;inotify_event&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;		wd;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt;	mask;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt;	cookie;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt;	len;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;	name[];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="The Linux Programming Interface" scheme="https://m033010041.github.io/tags/The-Linux-Programming-Interface/"/>
    
      <category term="Linux" scheme="https://m033010041.github.io/tags/Linux/"/>
    
      <category term="讀書心得" scheme="https://m033010041.github.io/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>[讀書心得] The Linux Programming Interface 第 11 章：系統限制</title>
    <link href="https://m033010041.github.io/2018/10/03/TLPI-SysLimit/"/>
    <id>https://m033010041.github.io/2018/10/03/TLPI-SysLimit/</id>
    <published>2018-10-03T01:44:14.000Z</published>
    <updated>2018-11-21T16:42:04.111Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ getconf NAME_MAX ~/Desktop</span><br><span class="line">255</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>每個 Unix 系統對各種系統功能與資源受限，並提供(或是選擇不提供)由各種標準定義的選項，例如：</p><ul><li>一個行程能同時開啟多少個檔案？</li><li>系統是否支援即時訊號？</li><li>型別為 <code>int</code> 的變數可儲存的最大值是多少？</li><li>一個程式能有多大的參數清單？</li><li>路徑名稱的最大長度是多少？</li></ul><p>我們通常會制定一個應用程式的限制與選項(limits or options)， <strong>但會減少可攜性</strong> ，因為限制與選項會與 <strong>系統不同而隨之改變</strong> ，像是說：</p><ul><li>跨 unix 系統：隨著不同的 unix 系統會造成 <code>int</code> 可儲存的最大值不同。</li><li>在特地系統的執行期環境：應用程式可能是在 A 系統編譯，按對於 B 系統中有著不同的限制情形。</li><li>file system 的轉移：<ul><li>SystemV：檔名長度最多 14 位元組</li><li>BSD file system：檔名程度最多 255 位元組</li></ul></li></ul><h2 id="11-1-系統限制"><a href="#11-1-系統限制" class="headerlink" title="11.1 系統限制"></a>11.1 系統限制</h2><p>SUSv3 要求全部的系統，對於 SUSv3 指定的限制都要<strong>提供一個最小值</strong>，這樣就可以移植到遵循此標準的系統，通常會在 <code>&lt;limit.h&gt;</code> 常數中定義，命名原則使用前綴 <code>_POSIX_</code> 字串，而且<strong>通常</strong>包含 <code>_MAX</code> 字串，所以命名格式通常為 <code>_POSIX_XXX_MAX</code></p><blockquote><p>這邊其實很弔詭，其實命名 <strong>_MAX</strong> 但稱其名稱為最小值是一件很怪的事<br>當我們了解這個常數是用來定義某些資源或特性上限值的常數，此上限值必須有明確的最小值時，就可以清楚理解了。</p></blockquote><p>By the way: 在編譯的過程中遇到了一個問題，macos high sierra 升級到 macos mojave 之後執行 gcc -o … 會跳出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun</span><br></pre></td></tr></table></figure><p>此時的處理方式是透過 <a href="https://apple.stackexchange.com/questions/254380/macos-mojave-invalid-active-developer-path" target="_blank" rel="noopener">這個處理方式</a> 來解決，執行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure></p><p>在 mac 系統中</p><ul><li><code>limits.h</code> 放置於 <code>/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/limits.h</code></li><li><code>unistd.h</code> 放置於 <code>/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/unistd.h</code></li></ul><p>SUSv3 將其規範限制分成三類</p><ol><li>執行期恆定值(runtime invariant value)</li><li>路徑名稱變動值(pathname variable value)</li><li>執行期可增值(runtime increasable value)</li></ol><h3 id="執行期恆定值-runtime-invariant-value"><a href="#執行期恆定值-runtime-invariant-value" class="headerlink" title="執行期恆定值(runtime invariant value)"></a>執行期恆定值(runtime invariant value)</h3><h3 id="路徑名稱變動值-pathname-variable-value"><a href="#路徑名稱變動值-pathname-variable-value" class="headerlink" title="路徑名稱變動值(pathname variable value)"></a>路徑名稱變動值(pathname variable value)</h3><h3 id="執行期可增值-runtime-increasable-value"><a href="#執行期可增值-runtime-increasable-value" class="headerlink" title="執行期可增值(runtime increasable value)"></a>執行期可增值(runtime increasable value)</h3><ul><li>參數命名：於執行期時可用於 <code>sysconf()</code> 或是 <code>pathconf()</code> 以取得系統的限制值<ul><li><code>_SC_</code> 開頭的常數可用於 <code>sysconf()</code></li><li><code>_PC_</code> 開頭的常數可用於 <code>pathconf()</code> 或是 <code>fpathconf()</code></li></ul></li></ul><h3 id="從-shell-取得限制與選項：getconf"><a href="#從-shell-取得限制與選項：getconf" class="headerlink" title="從 shell 取得限制與選項：getconf"></a>從 shell 取得限制與選項：<code>getconf</code></h3><p>執行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ getconf variable-name [pathname]</span><br></pre></td></tr></table></figure></p><h2 id="11-2-在執行期取得系統限制與選項-sysconf"><a href="#11-2-在執行期取得系統限制與選項-sysconf" class="headerlink" title="11.2 在執行期取得系統限制與選項 sysconf()"></a>11.2 在執行期取得系統限制與選項 <code>sysconf()</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns value of limit specified by name,</span></span><br><span class="line"><span class="comment"> * or -1 if limit is indeterminate or an error occurred</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sysconf</span><span class="params">(<span class="keyword">int</span> name)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>參數 <code>name</code> 是定義於 <code>&lt;unistd.h&gt;</code> 的其中一個 <code>_SC_*</code> 常數</li><li>回傳內容即為限制值</li><li>若錯誤發生活是無法確定限制時則會回傳 -1，且 <strong>errno 非 0</strong> ，表示發生錯誤</li></ul><p>在 SUSv3 的規範之中，<em>sysconf()</em> 所傳回的限制值在呼叫的行程之生命週期內<strong>必須是個常數</strong></p><h2 id="11-3-在執行期取得檔案限制與選項-pathconf-fpathconf"><a href="#11-3-在執行期取得檔案限制與選項-pathconf-fpathconf" class="headerlink" title="11.3 在執行期取得檔案限制與選項 pathconf() / fpathconf()"></a>11.3 在執行期取得檔案限制與選項 <code>pathconf() / fpathconf()</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Both return value of limit specified by name,</span></span><br><span class="line"><span class="comment"> * or -1 if limit is indterminate or an error occurred</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">pathconf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fpathconf</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> name)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>pathconf()</code> 與 <code>fpathconf()</code> 不同之處就在於<ul><li><code>pathconf()</code> 輸入參數為路徑字串</li><li><code>fpathconf()</code> 是使用 file descriptor</li></ul></li><li>參數 <code>name</code> 是定義於 <code>&lt;unistd.h&gt;</code> 的其中一個 <code>_PC_*</code> 系列常數</li><li>與 <code>sysconf()</code> 相同地，回傳的結果我即為限制值，且可區分回傳的是限制值還是錯誤，也可以用 errno 分辨錯誤</li><li>與 <code>sysconf()</code> 不同的是：SUSv3 並不要求 <em>pathconf() / fpathconf()</em> 的回傳值必須在形成的生命週期內保持不變。例如，行程執行時， <strong>檔案系統可能會被卸載並以不同的性質重新裝載</strong></li></ul><h2 id="延伸：autoconf-automake-aclocal"><a href="#延伸：autoconf-automake-aclocal" class="headerlink" title="延伸：autoconf + automake + aclocal"></a>延伸：autoconf + automake + aclocal</h2><p>GNU Autoconf 是一個擴充工具，可以<strong>確定各種系統特性及限制的存在及設定</strong>，autoconf 可以基於所收集到的資訊而產生標頭檔，並將這些檔案 include 進 C 程式中。</p><h3 id="透過-autoconf-automake-aclocal-自動產生-Makefile"><a href="#透過-autoconf-automake-aclocal-自動產生-Makefile" class="headerlink" title="透過 autoconf + automake + aclocal 自動產生 Makefile"></a>透過 autoconf + automake + aclocal 自動產生 Makefile</h3><ul><li>首先要先安裝相關套件<br><code>brew install autoconf automake libtool</code></li><li><p>安裝完後就找一個 .c 檔試試看</p><ol><li>執行 <code>autoscan</code></li><li>會產生 <code>configure.scan</code></li><li><p>修改 <code>configure.scan</code> 後將其檔名修改成 <code>configure.in</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Process this file with autoconf to produce a con figure script.</span></span><br><span class="line"></span><br><span class="line">AC_INIT(src.c)</span><br><span class="line">AM_INIT_AUTOMAKE(src, 1.0)</span><br><span class="line"><span class="comment"># Checks for programs.</span></span><br><span class="line">AC_PROG_CC</span><br><span class="line"><span class="comment"># Checks for libraries.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Checks for header files.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Checks for typedefs, structures, and compiler ch aracteristics.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Checks for library functions.</span></span><br><span class="line"></span><br><span class="line">AC_OUTPUT(Makefile)</span><br></pre></td></tr></table></figure></li><li><p>執行 <code>aclocal</code></p></li><li>執行 <code>autoconf</code></li><li>應該會產生 <code>aclocal.m4 configure configure.in src.c</code></li><li><p>編輯 <code>Makefile.am</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AUTOMAKE_OPTIONS= foreign</span><br><span class="line"></span><br><span class="line">bin_PROGRAMS= src</span><br><span class="line"></span><br><span class="line">hello_SOURCES= src.c</span><br></pre></td></tr></table></figure></li><li><p>執行 <code>automake --add-missing</code></p></li><li>執行 <code>./configure</code></li><li>應該會產生 Makefile 等檔案</li><li>執行 <code>make / make install / make dist</code> 等即可</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ getconf NAME_MAX ~/Desktop&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;255&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="The Linux Programming Interface" scheme="https://m033010041.github.io/tags/The-Linux-Programming-Interface/"/>
    
      <category term="Linux" scheme="https://m033010041.github.io/tags/Linux/"/>
    
      <category term="讀書心得" scheme="https://m033010041.github.io/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>AM335X U-Boot SPL 的 CCS 環境建置與除錯方法整理</title>
    <link href="https://m033010041.github.io/2018/01/29/am335x-spl-css/"/>
    <id>https://m033010041.github.io/2018/01/29/am335x-spl-css/</id>
    <published>2018-01-29T09:11:20.000Z</published>
    <updated>2018-11-28T06:00:26.564Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/DcJfYlo.png" alt="Imgur"></p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工作時，工作任務中需要修改 U-boot 前端的程式碼，也就是 xloader (MLO)，這一個部分雖然可以透過 printf() 進行除錯，但是對於某些方面還是會發生問題，使用 CCS 進行除錯可以了解暫存器的存儲、組合語言的單部執行，以利我們可以更快的找到問題點，此文章紀錄了 CCS 環境建置與建議的除錯方法進行整理</p><p><a href="https://read01.com/zh-tw/a0dm7j.html#.Wmp5IHVuYbx" target="_blank" rel="noopener">參考資料</a> ，若有不懂的地方可以翻這個網站參考</p><p>TI 原廠也有提供 <a href="http://www.ti.com.cn/cn/lit/an/zhca539/zhca539.pdf" target="_blank" rel="noopener">簡體中文的使用手冊</a> 可以查找</p><hr><h2 id="Outline"><a href="#Outline" class="headerlink" title="Outline"></a>Outline</h2><ul><li><a href="#軟體安裝流程">軟體安裝流程</a><ul><li><a href="#Download-CCS">Download CCS</a></li><li><a href="#Install-Sitara-Series-Device-Support">Install Sitara Series Device Support</a></li></ul></li><li><a href="#建立-Project">建立 Project</a></li><li><a href="#JTAG-設定流程">JTAG 設定流程</a><ul><li><a href="#製作-JTAG-ccxml-檔案">製作 JTAG .ccxml 檔案</a></li><li><a href="#Connect-JTAG-to-MT6071iE">Connect JTAG to MT6071iE</a></li><li><a href="#build-debug-MLO">Build debug MLO</a></li><li><a href="#Load-Memory-Load-raw-data-to-cpu-memory">Load Memory (Load raw data to cpu memory)</a></li><li><a href="#Load-Symbol">Load Symbol</a></li><li><a href="#設置中斷點">設置中斷點</a></li></ul></li></ul><hr><h3 id="Download-CCS"><a href="#Download-CCS" class="headerlink" title="Download CCS"></a>Download CCS</h3><ul><li>LINK: <a href="http://processors.wiki.ti.com/index.php/Download_CCS" target="_blank" rel="noopener">http://processors.wiki.ti.com/index.php/Download_CCS</a></li><li>找最新版本</li><li>之後選擇 offline download 如圖<br><img src="https://i.imgur.com/QxCyuH6.png" alt="Imgur"></li><li>download 後解壓縮，進入資料夾內部執行<br><code>./ccs_setup_linux64_7.4.0.00015.bin</code></li><li>安裝最後一步，可勾選 create desktop icon，比較方便執行</li></ul><h3 id="Install-Sitara-Series-Device-Support"><a href="#Install-Sitara-Series-Device-Support" class="headerlink" title="Install Sitara Series Device Support"></a>Install Sitara Series Device Support</h3><ul><li><p>GOTO: <a href="http://processors.wiki.ti.com/index.php/File:Bookmarks_device_support.zip" target="_blank" rel="noopener">http://processors.wiki.ti.com/index.php/File:Bookmarks_device_support.zip</a></p></li><li><p>選擇最新的 Bookmark_device_support.zip 下載，下載完後解壓縮到你喜愛的路徑</p></li><li>開啟 CCSv7，執行上方工具列 Windows -&gt; Perferences</li><li>點開後，左側欄位選擇 Install/Update -&gt; Available Software Sites. -&gt; 點擊 Import -&gt; 選擇目標xml file</li></ul><p><img src="https://i.imgur.com/DcJfYlo.png" alt="Imgur"></p><ul><li>引入後，不要忘了點擊上方工具列 Help -&gt; Check for Updates 應該就會跳出安裝圖示了</li><li>選擇 Sitara Device Support 來更新套件</li></ul><p>若無法透過上面安裝</p><ul><li>不需要載任何的 device_support 檔案，直接點擊上方列 Help -&gt; Install New Software</li><li>Work with 填入網址 <code>http://software-dl.ti.com/ccs/esd/device_support_sitara</code></li><li>將全部的套件安裝好即可</li><li>以上設定完成</li></ul><h2 id="建立-Project"><a href="#建立-Project" class="headerlink" title="建立 Project"></a>建立 Project</h2><ul><li>開啟 CCSv7</li><li>點擊 File -&gt; New -&gt; Import</li><li>選擇 C/C++ -&gt; Existing Code as Makefile Project -&gt; Next<br><img src="https://i.imgur.com/4yfMlq2.png" alt=""></li><li>選擇 uboot 的路徑 -&gt; 確認後按下 Finish<br><img src="https://i.imgur.com/5b7QfZc.png" alt=""></li><li>建立完成</li></ul><h2 id="JTAG-設定流程"><a href="#JTAG-設定流程" class="headerlink" title="JTAG 設定流程"></a>JTAG 設定流程</h2><h3 id="製作-JTAG-ccxml-檔案"><a href="#製作-JTAG-ccxml-檔案" class="headerlink" title="製作 JTAG .ccxml 檔案"></a>製作 JTAG .ccxml 檔案</h3><ul><li>將 XDS100v2 JTAG Debug tool 接到電腦上，另一端接上</li><li>上方工具列 File -&gt; New -&gt; Target Configuration File</li><li>看是否要修改名稱，我是直接命名成 XDS100V2.ccxml，修改完後點擊 Next</li><li>Connection 選擇 XDS100v2 USB Debug Probe</li><li>若 Device Support有安裝成功，Board or Device 可選到 AM3352</li><li>Save Configuration 點擊 Save 後 Test Connection 會跳出按鈕可以點擊<br><img src="https://i.imgur.com/kmTy6p8.png" alt=""></li><li>點擊 Test Connection 測試成功的內容可以看到<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-----[Perform the Integrity scan-test on the JTAG IR]------------------------</span></span><br><span class="line"></span><br><span class="line">This test will use blocks of 64 32-bit words.</span><br><span class="line">This test will be applied just once.</span><br><span class="line"></span><br><span class="line">Do a test using 0xFFFFFFFF.</span><br><span class="line">Scan tests: 1, skipped: 0, failed: 0</span><br><span class="line">Do a test using 0x00000000.</span><br><span class="line">Scan tests: 2, skipped: 0, failed: 0</span><br><span class="line">Do a test using 0xFE03E0E2.</span><br><span class="line">Scan tests: 3, skipped: 0, failed: 0</span><br><span class="line">Do a test using 0x01FC1F1D.</span><br><span class="line">Scan tests: 4, skipped: 0, failed: 0</span><br><span class="line">Do a test using 0x5533CCAA.</span><br><span class="line">Scan tests: 5, skipped: 0, failed: 0</span><br><span class="line">Do a test using 0xAACC3355.</span><br><span class="line">Scan tests: 6, skipped: 0, failed: 0</span><br><span class="line">All of the values were scanned correctly.</span><br><span class="line"></span><br><span class="line">The JTAG IR Integrity scan-test has succeeded.</span><br></pre></td></tr></table></figure></li></ul><p>看到任何一個 fail 都要除錯</p><h3 id="Connect-JTAG-to-MT6071iE"><a href="#Connect-JTAG-to-MT6071iE" class="headerlink" title="Connect JTAG to MT6071iE"></a>Connect JTAG to MT6071iE</h3><ul><li>之後點擊 View -&gt; Target Configuration</li><li><p>選擇 User Defined -&gt; 檔案按右鍵 -&gt; Launch Selected Configuration</p><div style="text-align: center"><br><img src="https://i.imgur.com/ek4GoEU.png"><br></div></li><li><p>之後會跳到 debug 頁面，應該會看到以下圖片<br><img src="https://i.imgur.com/xcFg2KW.png" alt=""></p></li><li>選擇 Probe_0/CortexA8(Disconnected: Unknown) (通常是第2項)</li><li>右鍵選擇 Connect Target</li><li>連線完成</li></ul><p>連線未成功通常是沒有接穩，或是剛剛的 Test Connection 沒有通過</p><h3 id="build-debug-MLO"><a href="#build-debug-MLO" class="headerlink" title="build debug MLO"></a>build debug MLO</h3><ul><li><p>修改 ti_uboot/config.mk</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/config.mk b/config.mk</span><br><span class="line">index b7cd481..3495099 100644</span><br><span class="line"><span class="comment">--- a/config.mk</span></span><br><span class="line"><span class="comment">+++ b/config.mk</span></span><br><span class="line">@@ -60,7 +60,7 @@ PLATFORM_LDFLAGS =</span><br><span class="line"></span><br><span class="line"> #########################################################################</span><br><span class="line"></span><br><span class="line"><span class="deletion">-HOSTCFLAGS     = -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer \</span></span><br><span class="line"><span class="addition">+HOSTCFLAGS     = -Wall -Wstrict-prototypes -fomit-frame-pointer \</span></span><br><span class="line">                  $(HOSTCPPFLAGS)</span><br><span class="line"> HOSTSTRIP      = strip</span><br><span class="line"></span><br><span class="line">@@ -315,8 +315,8 @@ export      CONFIG_SYS_TEXT_BASE PLATFORM_CPPFLAGS PLATFORM_RELFLAGS CPPFLAGS CFLAGS</span><br><span class="line"></span><br><span class="line"> # Allow boards to use custom optimize flags on a per dir/file basis</span><br><span class="line"> BCURDIR = $(subst $(SRCTREE)/,,$(CURDIR:$(obj)%=%))</span><br><span class="line"><span class="deletion">-ALL_AFLAGS = $(AFLAGS) $(AFLAGS_$(BCURDIR)/$(@F)) $(AFLAGS_$(BCURDIR))</span></span><br><span class="line"><span class="deletion">-ALL_CFLAGS = $(CFLAGS) $(CFLAGS_$(BCURDIR)/$(@F)) $(CFLAGS_$(BCURDIR))</span></span><br><span class="line"><span class="addition">+ALL_AFLAGS = $(AFLAGS) $(AFLAGS_$(BCURDIR)/$(@F)) $(AFLAGS_$(BCURDIR)) -g</span></span><br><span class="line"><span class="addition">+ALL_CFLAGS = $(CFLAGS) $(CFLAGS_$(BCURDIR)/$(@F)) $(CFLAGS_$(BCURDIR)) -g</span></span><br><span class="line"> EXTRA_CPPFLAGS = $(CPPFLAGS_$(BCURDIR)/$(@F)) $(CPPFLAGS_$(BCURDIR))</span><br><span class="line"> ALL_CFLAGS += $(EXTRA_CPPFLAGS)</span><br></pre></td></tr></table></figure></li><li><p>執行 <code>./build.sh</code> 產生執行檔</p></li><li><p>可以看到產生幾個檔案</p><ul><li>MLO：放在 ti_uboot 或是 ti_uboot/am335x</li><li>u-boot-spl：放在 ti_uboot/am335x/spl <strong>是 MLO 的 symbol file</strong> 非常重要</li><li>u-boot-spl.bin：放在 ti_uboot/am335x/spl 是 MLO 的 raw data，<strong>可用於直接 loading 到 CPU 的 mem 中</strong></li></ul></li><li><p>我們將會專注在 u-boot-spl.bin 以及 u-boot-spl 這兩支檔案</p></li></ul><h3 id="Load-Memory-Load-raw-data-to-cpu-memory"><a href="#Load-Memory-Load-raw-data-to-cpu-memory" class="headerlink" title="Load Memory (Load raw data to cpu memory)"></a>Load Memory (Load raw data to cpu memory)</h3><ul><li><p>load mem 之前，我們要先看一下 spl 執行的 start address</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SPL_TEXT_BASE            0x402F0400</span></span><br></pre></td></tr></table></figure></li><li><p>datasheet 也有給予資料可參考<br><img src="https://i.imgur.com/4DQ3K3C.png" alt=""></p></li><li>回到 CCS，此時 JTAG 應該是處於 <strong>已連線</strong> 的狀況</li><li>點擊上方工具列 tool -&gt; Load Memory</li><li>選擇 u-boot-spl.bin raw data -&gt; File Type select Binary -&gt; Next</li><li><p><img src="https://i.imgur.com/zhNIAkx.png" alt=""></p></li><li><p>Start Address 填入 0x402f0400 -&gt; Finish<br><img src="https://i.imgur.com/zw3fr2t.png" alt=""></p></li><li><p>上面工具列 View -&gt; Disassambly 可以看到目前的PC位置</p></li><li><p>或是查看上方的 Registers -&gt; Core Registers -&gt; PC (program counter)<br><img src="https://i.imgur.com/D8HYOgv.png" alt=""></p></li><li><p>確認無誤後，Load mem 完成</p></li></ul><h3 id="Load-Symbol"><a href="#Load-Symbol" class="headerlink" title="Load Symbol"></a>Load Symbol</h3><ul><li>這邊就簡單許多了，直接點擊上方 Run -&gt; Load -&gt; Load Symbol</li><li>檔案選擇 <code>ti_uboot/am335x/spl/u-boot-spl</code> 後按下OK即可</li><li>之後視窗會出現 start.S 的頁面，此時已經可以開始設定中斷點了</li><li>Load Symbol 完成</li></ul><h3 id="設置中斷點"><a href="#設置中斷點" class="headerlink" title="設置中斷點"></a>設置中斷點</h3><ul><li>假設我要在其中一個指令增加中斷點的話，務必在該程式碼按下右鍵 -&gt; Break Point (Code Composer Studio) -&gt; Break Point</li><li>右上方的 Breakpoint 應該會跳出，並且Action 設定成 <strong>“Remain Halted”</strong></li><li>按下 Run 的執行鈕應該就會停在該程式碼了</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/DcJfYlo.png&quot; alt=&quot;Imgur&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://m033010041.github.io/tags/Linux/"/>
    
      <category term="Embedded Linux" scheme="https://m033010041.github.io/tags/Embedded-Linux/"/>
    
      <category term="am335x" scheme="https://m033010041.github.io/tags/am335x/"/>
    
  </entry>
  
  <entry>
    <title>2017 暑期系統軟體課程台北場(課前測驗題)</title>
    <link href="https://m033010041.github.io/2017/07/17/2017SysProg/"/>
    <id>https://m033010041.github.io/2017/07/17/2017SysProg/</id>
    <published>2017-07-17T05:33:42.000Z</published>
    <updated>2018-11-21T17:19:35.372Z</updated>
    
    <content type="html"><![CDATA[<p>上班之餘，看到了 jserv 的軟體課程，花了一點時間看看。以下是我寫程式途中所的開發筆記與成果</p><p>題目詳細內容：<a href="https://hackmd.io/s/B1wb8CyHb" target="_blank" rel="noopener">課前測驗題</a><br>程式內容(Github)：<a href="https://github.com/m033010041/2017_sysprog" target="_blank" rel="noopener">請點我</a></p><a id="more"></a><h2 id="Question-01"><a href="#Question-01" class="headerlink" title="Question 01"></a>Question 01</h2><p>以下是題目給予的程式碼：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="keyword">uint32_t</span> func(<span class="keyword">uint32_t</span> x) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> n = x;</span><br><span class="line">    n = ((n &amp; <span class="number">0xffff0000</span>) &gt;&gt; <span class="number">16</span>) | ((n &amp; <span class="number">0x0000ffff</span>) &lt;&lt; <span class="number">16</span>);</span><br><span class="line">    n = ((n &amp; <span class="number">0xff00ff00</span>) &gt;&gt;  <span class="number">8</span>) | ((n &amp; <span class="number">0x00ff00ff</span>) &lt;&lt;  <span class="number">8</span>);</span><br><span class="line">    n = ((n &amp; <span class="number">0xf0f0f0f0</span>) &gt;&gt;  <span class="number">4</span>) | ((n &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt;  <span class="number">4</span>);</span><br><span class="line">    n = ((n &amp; <span class="number">0xcccccccc</span>) &gt;&gt;  <span class="number">2</span>) | ((n &amp; <span class="number">0x33333333</span>) &lt;&lt;  <span class="number">2</span>);</span><br><span class="line">    n = ((n &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt;  <span class="number">1</span>) | ((n &amp; <span class="number">0x55555555</span>) &lt;&lt;  <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="我的解答："><a href="#我的解答：" class="headerlink" title="我的解答："></a>我的解答：</h3><p>仔細觀察後可以發現這個 function 會將數值 x 的 bit 從大範圍至小範圍進行交換，這種算是有效率的 bit reverse algorithm</p><p>bit reverse algorithm 最常用在快速傅立葉轉換 (FFT) 中，裡面有一個重要的步驟，就是透過 butterfly 網路進行頻率降取樣 (decimation-in-frequency) 的時候，需要變換輸入點的編號 (order)</p><p><img src="https://i.imgur.com/KFqpUCV.gif" alt="8 point FFT"></p><p>以下是透過 for/while 所改寫的 bit reverse function</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="keyword">uint32_t</span> func1(<span class="keyword">uint32_t</span> x) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> r = x &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> shift = <span class="keyword">sizeof</span>(x) * <span class="number">8</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(x = x &gt;&gt; <span class="number">1</span>; x; x&gt;&gt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r = r &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        r = r | (x &amp; <span class="number">1</span>);</span><br><span class="line">        shift--;</span><br><span class="line">    &#125;</span><br><span class="line">    r &lt;&lt;= shift;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這個方式就是先觀察 x 是否為 0 ，若不為 0 就進行右移，存入 r 中後進行左移，當 x = 0 時看還剩下多少需要左移的數量一次移完，這種寫法的好處是我 16 bit 的做法只要把 input/output 的宣告改掉即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="keyword">uint16_t</span> func2(<span class="keyword">uint16_t</span> x) &#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> r = x &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> shift = <span class="keyword">sizeof</span>(x) * <span class="number">8</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(x = x &gt;&gt; <span class="number">1</span>; x; x&gt;&gt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r = r &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        r = r | (x &amp; <span class="number">1</span>);</span><br><span class="line">        shift--;</span><br><span class="line">    &#125;</span><br><span class="line">    r &lt;&lt;= shift;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2#.E7.AE.97.E6.B3.95.E5.AE.9E.E7.8E.B0" target="_blank" rel="noopener">快速傅立葉轉換：bit reverse</a><br><a href="http://www.idi.ntnu.no/~elster/pubs/elster-bit-rev-1989.pdf" target="_blank" rel="noopener">fast bit reversal algorithm</a></p><h2 id="Question-02"><a href="#Question-02" class="headerlink" title="Question 02"></a>Question 02</h2><p>乘法器實作，其實看的範例的乘法器，那個 half_add()，似乎是全加器欸？</p><p>因為 <code>return half_add(sum, carry);</code> 補進去之後就變成了 ripple-carry adder 了</p><p>剛開始我的想法是，給定一個被乘數 a 和乘數 b，表示 a 會 <strong>被加 b 次</strong> ，由這個簡單的想法我可以把 code 寫成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> mul32(<span class="keyword">uint32_t</span> a, <span class="keyword">uint32_t</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> result=<span class="number">0</span>, i;</span><br><span class="line">    <span class="keyword">uint32_t</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=b; b; b&gt;&gt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)  <span class="comment">//if bit i is 1</span></span><br><span class="line">            result = half_add(result, (a&lt;&lt;j));</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但這樣似乎不符合 recurive 的規定，因此修改了程式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> mul32_recursive(<span class="keyword">uint32_t</span> a, <span class="keyword">uint32_t</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> half_add(((b&amp;<span class="number">1</span>)?a:<span class="number">0</span>), (mul32_recursive(a, b&gt;&gt;<span class="number">1</span>)&lt;&lt; <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這樣就大功告成囉～</p><h2 id="Question-05"><a href="#Question-05" class="headerlink" title="Question 05"></a>Question 05</h2><p>討論以下程式碼<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        fork();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   wait(<span class="literal">NULL</span>); wait(<span class="literal">NULL</span>); wait(<span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果將這個程式丟進 linux 執行後我們可以得到輸出的數值為 24，這個到底是什麼原因呢？理論上，<code>fork()</code> 執行 N 次，所產生的 process 數目應為 2^N^ - 1 個，因此此程式執行完後總共有 8 個 process (包含 main 程序)。</p><p>接下來我們討論 printf 的處理方式，printf 主要會 call <code>fprintf(stdout, &quot;...&quot;);</code></p><p>但是在 <a href="http://fanli7.net/a/bianchengyuyan/_NET/20120831/215063.html" target="_blank" rel="noopener">這篇文章</a> 中提到，<code>fork()</code> 執行時會先把資料丟到 <code>stdout</code> 的緩衝區，但是不會立即的觸發輸出，這個可能就是為什麼會輸出 24 的原因了</p><p>理論上所顯示的數目為 14 個，由下圖的分析可得知</p><p><img src="https://i.imgur.com/rpUw9JB.png" alt=""></p><p>因為 <code>fork()</code> 之後子程序會保留當下父程序的狀態，因此可以獲得 14 個 “-“ 符號，但是由於不會立即觸發 <code>stdout</code> 緩衝區，因此在    <code>fork()</code> 的當下其實 <code>stdout</code> 緩衝區的內容也一併被複製到子程序了，如下圖</p><p><img src="https://i.imgur.com/936j2Od.png" alt=""></p><p>因此輸出時會得到 24 個 “-“ 符號</p><p>喔對了，忘了補上如果直接觸發 <code>stdout</code> 緩衝區，其實只要透過 <code>&#39;\n&#39;</code> 這個字元就可以直接觸發 <code>stdout</code>，將結果直接印出來，我們只要修改 printf 即可獲得</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        fork();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-\n"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   wait(<span class="literal">NULL</span>); wait(<span class="literal">NULL</span>); wait(<span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這樣輸出就會變成是 14 個 “-“ 符號囉～</p><h3 id="參考資料-1"><a href="#參考資料-1" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="http://fanli7.net/a/bianchengyuyan/_NET/20120831/215063.html" target="_blank" rel="noopener">linux中fork（）函數詳解（原創！！實例講解）（轉載）</a></p><h2 id="Release-Note"><a href="#Release-Note" class="headerlink" title="Release Note"></a>Release Note</h2><p>三四題之後會在此文章補上<br>Q5 補上觸發緩衝區程式碼</p><p>comment</p><blockquote><p>This is Gugeegee.[name=劉安庭][color=#def29d]<br>[time=Mon, Jul 17, 2017 11:45 AM]<br>GitHub: <a href="https://github.com/m033010041/2017_sysprog" target="_blank" rel="noopener">https://github.com/m033010041/2017_sysprog</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上班之餘，看到了 jserv 的軟體課程，花了一點時間看看。以下是我寫程式途中所的開發筆記與成果&lt;/p&gt;
&lt;p&gt;題目詳細內容：&lt;a href=&quot;https://hackmd.io/s/B1wb8CyHb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;課前測驗題&lt;/a&gt;&lt;br&gt;程式內容(Github)：&lt;a href=&quot;https://github.com/m033010041/2017_sysprog&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;請點我&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="OS" scheme="https://m033010041.github.io/tags/OS/"/>
    
      <category term="system prog" scheme="https://m033010041.github.io/tags/system-prog/"/>
    
  </entry>
  
</feed>
