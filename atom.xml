<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Timmy的軟韌體開發筆記</title>
  
  <subtitle>累積經驗，分享經驗</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://m033010041.github.io/"/>
  <updated>2020-01-15T09:07:45.678Z</updated>
  <id>https://m033010041.github.io/</id>
  
  <author>
    <name>Timmy Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[讀書心得] The Linux Programming Interface 第 31 章：執行緒安全與個別執行緒儲存空間</title>
    <link href="https://m033010041.github.io/2020/01/14/TLPI-thread-safty/"/>
    <id>https://m033010041.github.io/2020/01/14/TLPI-thread-safty/</id>
    <published>2020-01-14T15:27:50.000Z</published>
    <updated>2020-01-15T09:07:45.678Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>第 31 章節主要是延伸第 30 章，介紹執行緒安全函式，以及單次初始化，從中探討如何使用執行緒特有的資料 (specific data) 以及執行緒區域儲存空間 (thread-local storage)，以讓現有的函式具有執行緒安全，而無需更動函式介面</p><a id="more"></a><h2 id="31-1-執行緒安全"><a href="#31-1-執行緒安全" class="headerlink" title="31.1 執行緒安全"></a>31.1 執行緒安全</h2><p>上週有提到這個程式<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> glob = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">incr</span><span class="params">(<span class="keyword">int</span> loops)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> loc, j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; loops; j++) &#123;</span><br><span class="line">        loc = glob;</span><br><span class="line">loc++;</span><br><span class="line">glob = loc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我們也討論出，<code>glob</code> 在多個執行緒執行 <code>incr()</code> 的情況下，會造成 <code>glob</code> 沒有辦法被預測<br>這不是我們所樂見的，所以針對 global 以及 static 變數，我們必須在執行緒中更加謹慎使用</p><p>有許多方式是可以使函式成為 thread-safty</p><ul><li>將一個函式、或是會共用之全域變數使用 <code>mutex</code> 進行關聯使用<ul><li>優點：簡易、單純</li><li>缺點：只能以「序列 (serialized)」方式存取資源，耗時，且導致失去同步效果</li></ul></li><li>將 mutex 與一個共用變數關聯<ul><li>優點：可以讓多個 thread 執行相同函式，並且可並行操作</li><li>缺點：要定義 critical section，若多個 thread 都要執行相同的 critical section，就沒辦法，乖乖等待吧</li></ul></li></ul><h3 id="簡易範例與說明"><a href="#簡易範例與說明" class="headerlink" title="簡易範例與說明"></a>簡易範例與說明</h3><p>這部分我們想要一個間單的例子作為說明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE  5               <span class="comment">/*共享緩衝區的大小*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sharedArray[MAXSIZE];        <span class="comment">/*sharedArray是共享緩衝區*/</span></span><br><span class="line"><span class="keyword">int</span> curr=<span class="number">-1</span>;                     <span class="comment">/*curr是用來指定sharedArray當前存有資料的最大位置*/</span></span><br><span class="line">                                 <span class="comment">/*注意,sharedArray和curr都屬於共享資料*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> empty=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> full=MAXSIZE;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> sharedMutex=PTHREAD_MUTEX_INITIALIZER; <span class="comment">/*鎖定臨界區的mutex*/</span></span><br><span class="line"><span class="keyword">sem_t</span> waitNonEmpty, waitNonFull; <span class="comment">/*等待"非空資源"和等待"非滿資源"的semaphor*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">readData</span><span class="params">(<span class="keyword">void</span> * whichone)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> data, position;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">                sem_wait(&amp;waitNonEmpty);             <span class="comment">/*是否有"非空資源"*/</span></span><br><span class="line"></span><br><span class="line">                pthread_mutex_lock(&amp;sharedMutex);    <span class="comment">/*進入臨界區*/</span></span><br><span class="line">                data = sharedArray[curr];</span><br><span class="line">                position = curr--;</span><br><span class="line">                <span class="built_in">printf</span> (<span class="string">"%s read from the %dth: %d, /n"</span>, (<span class="keyword">char</span>*)whichone, position, data);</span><br><span class="line">                sem_post(&amp;waitNonFull);              <span class="comment">/*生成一個"非滿資源"*/</span></span><br><span class="line">                pthread_mutex_unlock(&amp;sharedMutex);  <span class="comment">/*離開臨界區*/</span></span><br><span class="line"></span><br><span class="line">                sleep(<span class="number">2</span>);                            <span class="comment">/*跟同步無關的費時操作*/</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">writeData</span><span class="params">(<span class="keyword">void</span> * whichone)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> data, position;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                data=(<span class="keyword">int</span>)(<span class="number">10.0</span>*random()/RAND_MAX);    <span class="comment">/*生成一個隨機資料,注意是10.0而不是10*/</span></span><br><span class="line">                sem_wait(&amp;waitNonFull);                <span class="comment">/*是否有"非滿資源"*/</span></span><br><span class="line"></span><br><span class="line">                pthread_mutex_lock(&amp;sharedMutex);      <span class="comment">/*進入臨界區*/</span></span><br><span class="line">                position = ++curr;</span><br><span class="line">                sharedArray[curr]=data;</span><br><span class="line">                <span class="built_in">printf</span> (<span class="string">"%s wrote to the %dth: %d, /n"</span>, (<span class="keyword">char</span>*)whichone, position, data);</span><br><span class="line">                sem_post(&amp;waitNonEmpty);               <span class="comment">/*生成一個"非空資源"*/</span></span><br><span class="line">                pthread_mutex_unlock(&amp;sharedMutex);    <span class="comment">/*離開臨界區*/</span></span><br><span class="line"></span><br><span class="line">                sleep(<span class="number">1</span>);                              <span class="comment">/*跟同步無關的費時操作*/</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">pthread_t</span> consumer1, consumer2, producer1, producer2;    <span class="comment">/*兩個生產者和兩個消費者*/</span></span><br><span class="line">        sem_init(&amp;waitNonEmpty, <span class="number">0</span>, empty);                       <span class="comment">/*初始化訊號量*/</span></span><br><span class="line">        sem_init(&amp;waitNonFull, <span class="number">0</span>, full);</span><br><span class="line">        <span class="comment">/*注意,本問題中的兩種semaphore是有一定關係的,那就是它們的初始值之和應該等於共享緩衝區大小*/</span></span><br><span class="line">        <span class="comment">/*即empty+full等於MAXSIZE*/</span></span><br><span class="line"></span><br><span class="line">        pthread_create (&amp;consumer1, <span class="literal">NULL</span>, &amp;readData, <span class="string">"consumer1"</span>);</span><br><span class="line">        pthread_create (&amp;consumer2, <span class="literal">NULL</span>, &amp;readData, <span class="string">"consumer2"</span>);</span><br><span class="line">        pthread_create (&amp;producer1, <span class="literal">NULL</span>, &amp;writeData, <span class="string">"producer1"</span>);</span><br><span class="line">        pthread_create (&amp;producer2, <span class="literal">NULL</span>, &amp;writeData, <span class="string">"producer2"</span>);</span><br><span class="line">        pthread_join (consumer1, <span class="literal">NULL</span>);</span><br><span class="line">        pthread_join (consumer2, <span class="literal">NULL</span>);</span><br><span class="line">        pthread_join (producer1, <span class="literal">NULL</span>);</span><br><span class="line">        pthread_join (producer2, <span class="literal">NULL</span>);</span><br><span class="line">        sem_destroy(&amp;waitNonEmpty);</span><br><span class="line">        sem_destroy(&amp;waitNonFull);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>sem_wait()</code> 的說明如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sem_wait() decrements (locks) the semaphore pointed to by sem.  If</span><br><span class="line">the semaphore&apos;s value is greater than zero, then the decrement</span><br><span class="line">proceeds, and the function returns, immediately.  If the semaphore</span><br><span class="line">currently has the value zero, then the call blocks until either it</span><br><span class="line">becomes possible to perform the decrement (i.e., the semaphore value</span><br><span class="line">rises above zero), or a signal handler interrupts the call.</span><br></pre></td></tr></table></figure></p><p>以上面的例子我們做了一個簡單的 Q&amp;A：</p><h4 id="Q-需要幾個-mutex-？以及有幾個-semaphore？"><a href="#Q-需要幾個-mutex-？以及有幾個-semaphore？" class="headerlink" title="Q:需要幾個 mutex ？以及有幾個 semaphore？"></a>Q:需要幾個 mutex ？以及有幾個 semaphore？</h4><p>以上述的理論，應該是需要一個 mutex 以及會產生兩個 semaphore</p><ul><li>其中 <code>mutex</code> 是負責鎖定 <strong>critial section</strong> 的，以解決在 mutli-threading 中的 race condition</li><li>而 <code>semaphore</code> 是因為從例子中，消費者會因為緩衝區為空時被阻塞，而生產者則是緩衝區為滿的時候被阻塞，因此會需要兩個 semaphore</li></ul><h4 id="Q-有沒有需要修改什麼？"><a href="#Q-有沒有需要修改什麼？" class="headerlink" title="Q:有沒有需要修改什麼？"></a>Q:有沒有需要修改什麼？</h4><p>有，像是 <code>sleep()</code> 這種會影響執行緒的 non reentrancy function 應該拔掉</p><h3 id="非執行緒安全的函式"><a href="#非執行緒安全的函式" class="headerlink" title="非執行緒安全的函式"></a>非執行緒安全的函式</h3><p>在 <code>SUSv3</code> 的規範內，每個函式都要以「執行緒安全」的方式實作，除了下圖這些函式<br><img src="/2020/01/14/TLPI-thread-safty/SUSv3_no_thread_safety_funcs.png" alt=""></p><p>而 <code>SUSv4</code> 修改了上圖的 functions</p><ul><li>移除 <code>ecvt()</code>、<code>fcvt()</code>、<code>gcvt()</code>、<code>gethostbyname()</code>、<code>gethostbyaddr()</code>等，因為這是 SUSv4 已移除了標準 function</li><li>新增 <code>strsignal()</code> 以及 <code>system()</code>：<code>system()</code> 會使得操作影響整個行程，所以是 non-reentrant</li></ul><blockquote><p>NOTE: thread-safety 最初始的初衷就是 function 必須要有 reentrancy 的特性</p></blockquote><h3 id="reentrant-function-v-s-non-reentrant-function"><a href="#reentrant-function-v-s-non-reentrant-function" class="headerlink" title="reentrant function v.s non-reentrant function"></a>reentrant function v.s non-reentrant function</h3><p>對於最理想的狀況，我們會希望 thread 都是 reentrant functions，除了可以不需使用 mutex 即可到達 thread-safety，而且也會因為沒有 mutex 少了 mutex lock/unlock 的成本</p><p>實作方法：儘量避免使用 <code>global</code> 以及 <code>static</code> variables</p><p>但並非如此理想，有些函式還是無法被設計成 reentrant function：<a href="https://code.woboq.org/userspace/glibc/malloc/malloc.c.html" target="_blank" rel="noopener">例如 malloc lib</a></p><h2 id="31-2-One-Time-Initialization"><a href="#31-2-One-Time-Initialization" class="headerlink" title="31.2 One-Time Initialization"></a>31.2 One-Time Initialization</h2><p>多執行緒程式有時無論建立了多少個執行緒，會需要確保某些初始化動作只需要執行一次，例如：<code>pthread_mutex_init()</code> 會搭載特殊屬性進行初始化，並且只執行一次。</p><p>函式庫函式，可以透過 <code>pthread_once()</code> 執行一次性初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthrad.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns 0 on success, or a positive error number on error */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_once</span><span class="params">(<span class="keyword">pthread_once_t</span> *once_control, <span class="keyword">void</span> (*init)(<span class="keyword">void</span>))</span></span>;</span><br></pre></td></tr></table></figure><p><em>once_control</em> 參數是一個 pointer，必須指向 <code>PTHREAD_ONCE_INIT</code> 的靜態初始值<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_once_init once_var = PTHREAD_ONCE_INIT;</span><br></pre></td></tr></table></figure></p><p><code>init()</code> function 不應該帶任何參數，也不應該 return 任何參數</p><h2 id="31-3-執行緒特有資料-Thread-Specific-Data-TSD"><a href="#31-3-執行緒特有資料-Thread-Specific-Data-TSD" class="headerlink" title="31.3 執行緒特有資料 (Thread Specific Data, TSD)"></a>31.3 執行緒特有資料 (Thread Specific Data, TSD)</h2><p>要讓函式是 thread-safety，最有效的方式就是實作成 reentrant function，但若有函式會執行上述我們討論到的 non-thread-safety function 時，就必須修改自身的 API interface，簡單說，你想要在 <code>myfunc()</code> 裡面執行 <code>rand()</code> 函式，因為 <code>rand()</code> 可能是你的 thread 所需要執行的，結果你發現這個 API 會變成 non-thread-safety function，那怎麼辦呢？</p><ul><li>實作 <code>rand()</code> 或是找另一個方案，使 <code>myfunc()</code> 成為 thread-safety function</li><li>使用 TSD buffer 管理，直接實作於 <code>myfunc()</code> 中，如圖所示<br><img src="/2020/01/14/TLPI-thread-safty/TSD_buffer.png" width="60%"></li></ul><h3 id="如何實現"><a href="#如何實現" class="headerlink" title="如何實現"></a>如何實現</h3><p>實現步驟如下</p><ol><li>函式會建立一個 key，藉由 <code>pthread_key_create()</code> 建立，而 key 的建立是在執行緒呼叫此函式的時候建立一次，因此需要使用 <code>pthread_once()</code> 函式協助。此函式不會產生 TSD buffer</li><li>透過 <code>pthread_key_create()</code> 的產生 key 的過程中需要告知 destructor function，當 key 被釋放的時候會自動執行此 callback function</li><li>函式被任何執行緒呼叫的時候，會透過 <code>malloc</code> 配置一個 TSD buffer，而且由於 <code>pthread_once()</code> 的緣故，該執行緒的初始化只會執行一次</li><li>若要存取 TSD buffer 的位址，函式需要透過 <code>pthread_setspecific()</code> 以及 <code>pthread_getspecific()</code></li></ol><ul><li><code>pthread_setspecific()</code>：儲存此指標，並且記錄此指標相關的 key </li><li><code>pthread_getspecific()</code>：傳回之前儲存的指標以及之前呼叫此 function 的 thread key</li></ul><h4 id="API-declarsion"><a href="#API-declarsion" class="headerlink" title="API declarsion"></a>API declarsion</h4><p>首先是 <code>pthread_key_create()</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns 0 on success, or a positive error number on error */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_create</span><span class="params">(<span class="keyword">pthread_key_t</span> *key, <span class="keyword">void</span> (*destructor)(<span class="keyword">void</span> *))</span></span>;</span><br></pre></td></tr></table></figure></p><ul><li>因為傳回的 key 必須供每個執行緒使用，所以 key 應該指向一個 <strong>全域變數</strong></li><li>destructor 需要設計者自行實作</li><li>從 <code>pthread_key_t *key</code> 可以得知其實 key 就是一個陣列索引，所以可以透過一個全域陣列去存取 thread key，並分別處理 destructor function<br><img src="/2020/01/14/TLPI-thread-safty/TSD_key.png" width="60%"></li></ul><p>接下來是取得與設定的 Pthread API<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns 0 on success, or a positive error number on error */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setspecific</span><span class="params">(<span class="keyword">pthread_key_t</span> key, <span class="keyword">const</span> <span class="keyword">void</span> *value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns pointer, or NULL if no thread-specific data isassociated with key */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pthread_getspecific</span><span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span>;</span><br></pre></td></tr></table></figure></p><p>其中 <code>value</code> 是什麼呢？其實是 destructor function 要執行的時候，需要回傳的 pointer，如果我們傳入的是一個純值且強制 cast 成 void*，這種狀況下 <code>pthread_key_create()</code> 中的 destructor 就會被指定成 <code>NULL</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dest(<span class="keyword">void</span> *value)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/* Release storage pointed to by 'value' */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="實例"><a href="#實例" class="headerlink" title="實例"></a>實例</h2><p>實作一個 <code>strerror()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *</span><br><span class="line">strerror(<span class="keyword">int</span> err)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span> || err &gt;= _sys_nerr || _sys_errlist[err] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(buf, MAX_ERROR_LEN, <span class="string">"Unknown error %d"</span>, err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">strncpy</span>(buf, _sys_errlist[err], MAX_ERROR_LEN - <span class="number">1</span>);</span><br><span class="line">        buf[MAX_ERROR_LEN - <span class="number">1</span>] = <span class="string">'\0'</span>;          <span class="comment">/* Ensure null termination */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這是什麼呢？這就是當傳入 err 的時候會將 buf 填入相對應的字串，例如</p><ul><li><code>EINVAL</code>: Invalid arguemnts</li><li><code>EPERM</code>: Operation not permitted</li></ul><p>看完結果後，接下來我們照著 thread-safety 的方式設計</p><p>首先建立 create key function 並告知只要執行一次<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_key_t</span> strerrorKey;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>                         <span class="comment">/* One-time key creation function */</span></span><br><span class="line">createKey(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate a unique thread-specific data key and save the address</span></span><br><span class="line"><span class="comment">       of the destructor for thread-specific data buffers */</span></span><br><span class="line"></span><br><span class="line">    s = pthread_key_create(&amp;strerrorKey, destructor);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        errExitEN(s, <span class="string">"pthread_key_create"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">strerror</span><span class="params">(<span class="keyword">int</span> err)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make first caller allocate key for thread-specific data */</span></span><br><span class="line"></span><br><span class="line">    s = pthread_once(&amp;once, createKey);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        errExitEN(s, <span class="string">"pthread_once"</span>);</span><br><span class="line">    <span class="comment">/* ....... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下來透過 key 取得 TSD buffer (pointer)，若沒有就創一個 TSD buffer<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">buf = pthread_getspecific(strerrorKey);</span><br><span class="line"><span class="keyword">if</span> (buf == <span class="literal">NULL</span>) &#123;          <span class="comment">/* If first call from this thread, allocate</span></span><br><span class="line"><span class="comment">                               buffer for thread, and save its location */</span></span><br><span class="line">    buf = <span class="built_in">malloc</span>(MAX_ERROR_LEN);</span><br><span class="line">    <span class="keyword">if</span> (buf == <span class="literal">NULL</span>)</span><br><span class="line">        errExit(<span class="string">"malloc"</span>);</span><br></pre></td></tr></table></figure></p><p>接下來就是通知 thread ，紀錄此 key 以及相對應的 buf address<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (buf == <span class="literal">NULL</span>) &#123;          <span class="comment">/* If first call from this thread, allocate</span></span><br><span class="line"><span class="comment">                               buffer for thread, and save its location */</span></span><br><span class="line">    buf = <span class="built_in">malloc</span>(MAX_ERROR_LEN);</span><br><span class="line">    <span class="keyword">if</span> (buf == <span class="literal">NULL</span>)</span><br><span class="line">        errExit(<span class="string">"malloc"</span>);</span><br><span class="line"></span><br><span class="line">    s = pthread_setspecific(strerrorKey, buf);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        errExitEN(s, <span class="string">"pthread_setspecific"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最後就是 buf 要在 key 被釋放的時候執行的 destructor function<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>                         <span class="comment">/* Free thread-specific data buffer */</span></span><br><span class="line">destructor(<span class="keyword">void</span> *buf)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由以上的實作，就可以不需要更動 strerror_test.c 中的實作，將 <code>strerror()</code> function 變成 thread-safety function</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;第 31 章節主要是延伸第 30 章，介紹執行緒安全函式，以及單次初始化，從中探討如何使用執行緒特有的資料 (specific data) 以及執行緒區域儲存空間 (thread-local storage)，以讓現有的函式具有執行緒安全，而無需更動函式介面&lt;/p&gt;
    
    </summary>
    
    
      <category term="The Linux Programming Interface" scheme="https://m033010041.github.io/tags/The-Linux-Programming-Interface/"/>
    
      <category term="Linux" scheme="https://m033010041.github.io/tags/Linux/"/>
    
      <category term="讀書心得" scheme="https://m033010041.github.io/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>[leetcode] Two sum，初次體驗 leetcode</title>
    <link href="https://m033010041.github.io/2019/11/02/leetcode-two-sum/"/>
    <id>https://m033010041.github.io/2019/11/02/leetcode-two-sum/</id>
    <published>2019-11-02T13:13:32.000Z</published>
    <updated>2019-11-03T04:29:06.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自從創了帳號後都沒有認真的看裡面的題目</p><p>以前玩 UVA 的時候，頭腦動得很多，現在上班後有時候變成像是碼農一樣，只在專注的解問題，儘量求速度求 KPI</p><p>有時候還是應該檢視自己寫的程式到底是不是效能最好，是不是記憶體用量最低，或是這種寫法好不好維護，易讀性如何等等</p><p>當然在做 code review 的時候還是可以提醒同事或是讓同事指點程式寫得好不好，成本高不高</p><p>但因為我還是有點不懂裡面的運作方式，所以就先找最簡易的一題，先看看 leetcode 怎麼運作吧<br><a id="more"></a></p><h2 id="Leetcode-的運作模式"><a href="#Leetcode-的運作模式" class="headerlink" title="Leetcode 的運作模式"></a>Leetcode 的運作模式</h2><p>leetcode 主要似乎不太苛求 IO 的操作，他比較專注於演算法與系統設計<br>所以給你一個核心程式的 prototype ，在不更動 prototype 的情況下撰寫內部的核心演算法<br>之後 runtime 會透過此宣告的 IO 去執行函式，並取得解答</p><h2 id="Problem-description"><a href="#Problem-description" class="headerlink" title="Problem description"></a>Problem description</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Given an array of integers, return indices of the two numbers such that they add up to a specific target.</span><br><span class="line"></span><br><span class="line">You may assume that each input would have exactly one solution, and you may not use the same element twice.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Given nums = [2, 7, 11, 15], target = 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><h3 id="brute-force-暴力解"><a href="#brute-force-暴力解" class="headerlink" title="brute force (暴力解)"></a>brute force (暴力解)</h3><p>簡單說就是使用巢狀迴圈處理</p><p>如果用上面的 test case 來說明的話</p><p>就是會依循 [0, 1], [0, 2], [0, 3] 一直進行兩數和解<br>之後若相同就 return array index，這樣而已</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> *a = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;numsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>; j&lt;numsSize; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((nums[i] + nums[j]) == target) &#123;</span><br><span class="line">                returnSize[<span class="number">0</span>]=<span class="number">2</span>;</span><br><span class="line">                a[<span class="number">0</span>] = i;</span><br><span class="line">                a[<span class="number">1</span>] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而我們先看一下 function prototype<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span></span></span><br></pre></td></tr></table></figure></p><p>我們可以從這個 prototype 知道</p><ul><li><code>nums</code> 是 runtime 會傳入的陣列</li><li><code>numsSize</code> 是 runtime 會傳入的陣列大小</li><li><code>target</code> 是兩數和的解</li><li><code>returnSize</code> 我覺得這個沒有意義，就是 return 陣列的大小</li></ul><p>然後這題他給我的時候 prototype 還少了一個 <code>int* returnSize</code>，讓我一直 compiler error，感覺不是很好……</p><h3 id="調整解法：從-Loop-直接-return"><a href="#調整解法：從-Loop-直接-return" class="headerlink" title="調整解法：從 Loop 直接 return"></a>調整解法：從 Loop 直接 return</h3><p>這應該是最簡易的優化了，也就是說，我們本來是跑完全部總共 O(n^2) 的方式，這時候我們判斷好結果後就直接 return pointer 出去就好了</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Note: The returned array must be malloced, assume caller calls free().</span><br><span class="line"> */</span><br><span class="line">int* twoSum(int* nums, int numsSize, int target, int* returnSize) &#123;  </span><br><span class="line">    int i, j;</span><br><span class="line">    int *a = (int *)malloc(sizeof(int) * 2);</span><br><span class="line">    </span><br><span class="line">    for (i=0; i&lt;numsSize; i++) &#123;</span><br><span class="line">        for(j=i+1; j&lt;numsSize; j++) &#123;</span><br><span class="line">            if ((nums[i] + nums[j]) == target) &#123;</span><br><span class="line">                returnSize[0]=2;</span><br><span class="line">                a[0] = i;</span><br><span class="line">                a[1] = j;</span><br><span class="line"><span class="addition">+return a;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="deletion">-   return a;</span></span><br><span class="line"><span class="addition">+   return NULL;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>submit 所花的執行時間可以從 210 ms 進展到 135 ms</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;自從創了帳號後都沒有認真的看裡面的題目&lt;/p&gt;
&lt;p&gt;以前玩 UVA 的時候，頭腦動得很多，現在上班後有時候變成像是碼農一樣，只在專注的解問題，儘量求速度求 KPI&lt;/p&gt;
&lt;p&gt;有時候還是應該檢視自己寫的程式到底是不是效能最好，是不是記憶體用量最低，或是這種寫法好不好維護，易讀性如何等等&lt;/p&gt;
&lt;p&gt;當然在做 code review 的時候還是可以提醒同事或是讓同事指點程式寫得好不好，成本高不高&lt;/p&gt;
&lt;p&gt;但因為我還是有點不懂裡面的運作方式，所以就先找最簡易的一題，先看看 leetcode 怎麼運作吧&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://m033010041.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>[STM32] 在 STM32F469-Discovery 上閃爍 LED</title>
    <link href="https://m033010041.github.io/2019/08/25/stm32f469ni-blink-leds/"/>
    <id>https://m033010041.github.io/2019/08/25/stm32f469ni-blink-leds/</id>
    <published>2019-08-25T10:31:08.000Z</published>
    <updated>2019-08-25T10:42:39.781Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/08/25/stm32f469ni-blink-leds/IMG_7987.jpg" alt=""><br>以上的環境應該已經無關 Ubuntu 或是 macOS 了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2019/08/25/stm32f469ni-blink-leds/IMG_7987.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;以上的環境應該已經無關 Ubuntu 或是 macOS 了&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="STM32" scheme="https://m033010041.github.io/tags/STM32/"/>
    
      <category term="STM32F4" scheme="https://m033010041.github.io/tags/STM32F4/"/>
    
  </entry>
  
  <entry>
    <title>Firefly-R3288 的 JTAG 建置</title>
    <link href="https://m033010041.github.io/2019/07/28/FireFly-RK3288-JTAG-SETUP/"/>
    <id>https://m033010041.github.io/2019/07/28/FireFly-RK3288-JTAG-SETUP/</id>
    <published>2019-07-28T14:38:16.000Z</published>
    <updated>2019-07-28T14:44:26.865Z</updated>
    
    <content type="html"><![CDATA[<p>最近要在 Rockchip RK3288 上面跑 RTOS，為了讓同事可以在上面方便的除錯，我負責的部分就是要開通 RK3288 的 JTAG，並運行在 firefly-RK3288 的開發板上面<br>文章中說明了從 0 開始的設定過程，途中遇到的問題，以及要查找哪些資料，最後成功連線 JTAG<br><a id="more"></a></p><h2 id="開發順序"><a href="#開發順序" class="headerlink" title="開發順序"></a>開發順序</h2><p>再做設定之前，先說明一下我們所用的環境好了，我們要先了解軟硬體支援在下手，才知道我們是不是白做工，而我們所使用的環境是：</p><ol><li>JTAG: SEGGER JLINK BASE (hardware version: v9.4)</li><li>GDBServer: JLINK GDBServer</li><li>Rockchip RK3288 (ARM Coretex-A17, ARMv7 ISA)</li><li>Board: Firefly-RK3288</li><li>Debug 用具： USB 轉 TTL 傳輸線 (device: ttyUSB0, baud-rate: 115200 8,N,1)</li></ol><p>開發順序是：</p><ol><li>我們要先了解開發版資訊，在開發板上的 PIN 腳位置以及對應到晶片的 GPIO 位置</li><li>之後要進行初始化，我們選擇使用 RK3288 的 U-boot (bootloader) 來協助我們進行初始化</li><li>我們停在 U-boot command，等待 GDBServer 的回饋</li><li>透過 Ubuntu 的 JLINK GDBServer 連接上</li></ol><h2 id="開發版資訊"><a href="#開發版資訊" class="headerlink" title="開發版資訊"></a>開發版資訊</h2><p><a href="http://en.t-firefly.com/doc/download/4.html" target="_blank" rel="noopener">http://en.t-firefly.com/doc/download/4.html</a></p><h2 id="firefly-RK3288-Jtag-設定"><a href="#firefly-RK3288-Jtag-設定" class="headerlink" title="firefly RK3288 Jtag 設定"></a>firefly RK3288 Jtag 設定</h2><h3 id="JTAG-socket-type"><a href="#JTAG-socket-type" class="headerlink" title="JTAG socket type"></a>JTAG socket type</h3><p>JTAG/SW 分成兩種 socket: 5 線的 JTAG socket 以及 2 線的 SW socket</p><ul><li>JTAG socket 包括了 TDO、TDI、TRST_N、TMS、TCK 五條</li><li>SW socket 則是包括了 TMS 和 TCK 兩條</li></ul><p>我們所使用的是五線的 JTAG Socket</p><h3 id="從-Data-Sheet-找出開發版與晶片的對應腳位"><a href="#從-Data-Sheet-找出開發版與晶片的對應腳位" class="headerlink" title="從 Data Sheet 找出開發版與晶片的對應腳位"></a>從 Data Sheet 找出開發版與晶片的對應腳位</h3><p><a href="https://blog.csdn.net/groundhappy/article/details/58587912" target="_blank" rel="noopener">這裡有非常詳盡的解說</a></p><p>當然要先從官網下載 RK3288 的 <a href="http://opensource.rock-chips.com/images/8/8f/Rockchip_RK3288_TRM_V1.2_Part1-20170321.pdf" target="_blank" rel="noopener">user manual</a></p><p>我們發現 sdmmc0 與 jtag socket 腳位衝突，這部份我們會在 U-Boot 設定小結做說明</p><h3 id="從-Data-Sheet-找出需要設定的-register-address-amp-value"><a href="#從-Data-Sheet-找出需要設定的-register-address-amp-value" class="headerlink" title="從 Data Sheet 找出需要設定的 register address &amp; value"></a>從 Data Sheet 找出需要設定的 register address &amp; value</h3><p>設定是使用兩個 register，目前還沒有成功，但這兩個 register 跑不掉</p><h3 id="U-boot-端設定"><a href="#U-boot-端設定" class="headerlink" title="U-boot 端設定"></a>U-boot 端設定</h3><p>可以在兩個地方進行初始化，二擇一即可：</p><p>In arch/arm/mach-rockchip/rk3288-board-spl.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">board_init_f</span><span class="params">(ulong dummy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">udevice</span> *<span class="title">pinctrl</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">udevice</span> *<span class="title">dev</span>;</span></span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Example code showing how to enable the debug UART on RK3288 */</span></span><br><span class="line">        <span class="comment">/* Enable early UART on the RK3288 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GRF_BASE        0xff770000</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rk3288_grf</span> * <span class="title">const</span> <span class="title">grf</span> = (<span class="title">void</span> *)<span class="title">GRF_BASE</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rk3288_cru</span> * <span class="title">cru</span>;</span></span><br><span class="line">        <span class="comment">/* set jtag clock */</span></span><br><span class="line">        cru = (struct rk3288_cru *)rockchip_get_cru(); <span class="comment">//get cru addresses</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* set CLKGATE4_CON register, 0 is enable all clocks */</span></span><br><span class="line">        cru-&gt;cru_clkgate_con[<span class="number">4</span>] = <span class="number">0xFFFF0000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"=====%p=====: value = %08x\n"</span>,(<span class="keyword">void</span> *)cru,</span><br><span class="line">                                              cru-&gt;cru_clkgate_con[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* set bit 28 and 14 (mask and enable) */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"set jtag mode.\n"</span>);</span><br><span class="line">        grf-&gt;soc_con0 |= ((<span class="number">1</span>&lt;&lt;<span class="number">28</span>)+(<span class="number">1</span>&lt;&lt;<span class="number">14</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"=====%p=====: value = %08x\n"</span>,(<span class="keyword">void</span> *)&amp;grf-&gt;soc_con0,</span><br><span class="line">                                              grf-&gt;soc_con0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Or in arch/arm/mach-rockchip/rk3288-board.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">board_late_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rk3288_cru</span> * <span class="title">cru</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rk3288_grf</span> * <span class="title">grf</span> = (<span class="title">void</span> *)0<span class="title">xff770000</span>;</span></span><br><span class="line">        setup_boot_mode();</span><br><span class="line">        rk3288_qos_init();</span><br><span class="line">        rk3288_detect_reset_reason();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"board_late_init\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* set jtag clock */</span></span><br><span class="line">        cru = (struct rk3288_cru *)rockchip_get_cru(); <span class="comment">//get cru addresses</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* set CLKGATE4_CON register, 0 is enable all clocks */</span></span><br><span class="line">        cru-&gt;cru_clkgate_con[<span class="number">4</span>] = <span class="number">0xFFFF0000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"=====%p=====:%p value = %08x\n"</span>,(<span class="keyword">void</span> *)cru,</span><br><span class="line">                        &amp;cru-&gt;cru_clkgate_con[<span class="number">4</span>], cru-&gt;cru_clkgate_con[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"get jtag mode.\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ((1&lt;&lt;28)+(1&lt;&lt;12)); //set bit 28 and 14 (mask and enable) */</span></span><br><span class="line">        grf-&gt;soc_con0 = <span class="number">0x10000c18</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"=====%p=====: value = %08x\n"</span>,(<span class="keyword">void</span> *)&amp;grf-&gt;soc_con0,</span><br><span class="line">                                              grf-&gt;soc_con0);</span><br><span class="line">        grf-&gt;gpio6c_iomux = <span class="number">0xffff02aa</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rk_board_late_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="製作-U-Boot"><a href="#製作-U-Boot" class="headerlink" title="製作 U-Boot"></a>製作 U-Boot</h3><p>之後透過腳本 build 出 idbloader_SPL.img 就可以了，這就是我們要的檔案</p><h4 id="燒錄動作"><a href="#燒錄動作" class="headerlink" title="燒錄動作"></a>燒錄動作</h4><ul><li><p>put your sd card on your PC, and run command down below</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dd if=idbloader_SPL.img of=/dev/sdx  seek=64</span><br></pre></td></tr></table></figure><p>  sdx 就是你的 sd card partition</p></li><li>SD boot 開機即可</li></ul><h3 id="問題：設定完成後依舊無法連線"><a href="#問題：設定完成後依舊無法連線" class="headerlink" title="問題：設定完成後依舊無法連線"></a>問題：設定完成後依舊無法連線</h3><p>跳出訊息 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connecting to target...ERROR: Cortex-A/R-JTAG (connect): Could not determine address of core debug registers. Incorrect CoreSight ROM table in device?</span><br></pre></td></tr></table></figure><p>我預估有三種可能性</p><p>有數種可能性</p><ol><li>Jtag pin 腳設錯了</li><li>JLinkGDBServer 初始化腳本設錯了</li><li>JLink 軟硬體本身就不支援</li></ol><p>針對 1. 的問題我已經驗證過了，如果直接初始化 SD/MMC mode 的話，會直接跳出無法連線而不會跳出類似圖片的內容</p><p><img src="https://i.imgur.com/5vorGHh.png" alt=""></p><p>而 3. 的部份，我們也查證過了</p><p><img src="https://i.imgur.com/TJFchX0.png" alt=""></p><p>V9.1 才支援，我們的版本是有點舊，不過 yenchin 的 hardware version 是 9.4 應該還是沒問題才是</p><p>而 3 還有另一個問題，就是 SEGGER 本身有沒有支援？？<br>這部份很難查證，從 <a href="https://forum.segger.com/index.php/Thread/4341-SOLVED-JLinkGDBSserver-device-options-list/" target="_blank" rel="noopener">https://forum.segger.com/index.php/Thread/4341-SOLVED-JLinkGDBSserver-device-options-list/</a> 的教學，我們可以先透過 JLinkExe 上輸入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">weintek-timmy@weintek-timmy:~/Downloads/JLink_V612j$ JLinkExe </span><br><span class="line">SEGGER J-Link Commander V6.22g (Compiled Jan 17 2018 16:40:37)</span><br><span class="line">DLL version V6.22g, compiled Jan 17 2018 16:40:32</span><br><span class="line"></span><br><span class="line">Connecting to J-Link via USB...FAILED: Cannot connect to J-Link via USB.</span><br><span class="line"><span class="meta">J-Link&gt;</span><span class="bash">expdevlist list.txt</span></span><br><span class="line">Opening text file for writing... [list.txt]</span><br><span class="line"><span class="meta">J-Link&gt;</span><span class="bash"><span class="built_in">exit</span></span></span><br></pre></td></tr></table></figure><p>像是 NXP (freeescale) i.MX6 就有支援<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;Manufacturer&quot;, &quot;Device&quot;, &quot;Core&quot;, &#123;Flash areas&#125;, &#123;RAM areas&#125;</span><br><span class="line">&quot;NXP&quot;, &quot;MCIMX6U7&quot;, &quot;Cortex-A9&quot;, &#123;0x00000000, 0x00000000&#125;, &#123;0x00000000, 0x00000000&#125;</span><br></pre></td></tr></table></figure></p><p>所以 i.MX6 可以用以下兩種方式執行<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./JLinkGDBServer -select USB -device MCIMX6U7 -if JTAG -speed auto -noreset -noir</span><br><span class="line">./JLinkGDBServer -select USB -device Cortex-A9 -if JTAG -speed auto -noreset -noir</span><br></pre></td></tr></table></figure></p><p>A17 也有支援，不過是列在 unspecified 上面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;Manufacturer&quot;, &quot;Device&quot;, &quot;Core&quot;, &#123;Flash areas&#125;, &#123;RAM areas&#125;</span><br><span class="line">&quot;Unspecified&quot;, &quot;Cortex-A17&quot;, &quot;Cortex-A17&quot;, &#123;0x00000000, 0x00000000&#125;, &#123;0x00000000, 0x00000000&#125;</span><br></pre></td></tr></table></figure></p><p>所以可能是 2. 的問題</p><p>首先<a href="https://forum.segger.com/index.php/Thread/6052-SOLVED-Can-J-Link-BASE-connect-to-Rockchip-RK3288/?s=5b090bea25ad3bbacfbe6ebc13898c91eaf75d11" target="_blank" rel="noopener">透過論壇問了原廠</a>，原廠沒有很完善的解答，只寫說「請找 SoC vendor」</p><p>而我們突然在網路上找到一篇 datasheet TRM v0.3 似乎是開發期間的版本</p><p>裏面可以查到 DAP address 如下</p><p><img src="https://i.imgur.com/4Cc9ZSG.png" alt=""></p><p>之後根據之前的範例嘗試修改 JLink.script，已經可以讓 rk3288 與 jtag 連接上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/*********************************************************************</span><br><span class="line">*</span><br><span class="line">*       InitTarget</span><br><span class="line">*/</span><br><span class="line">void InitTarget(void) &#123;</span><br><span class="line">  JLINK_SYS_Report(&quot;Hello SEGGER JLINK&quot;);</span><br><span class="line">  Report(&quot;*************************************************&quot;);</span><br><span class="line">  Report(&quot;J-Link script: iMX7D Cortex-M4 core J-Link script&quot;);</span><br><span class="line">  Report(&quot;*************************************************&quot;);</span><br><span class="line">//  JLINK_CORESIGHT_Configure(&quot;IRPre=0;DRPre=0;IRPost=21;DRPost=2;IRLenDevice=4&quot;);</span><br><span class="line">  CPU = CORTEX_A17;                                                              // Pre-select that we have a Cortex-M4 connected</span><br><span class="line">  JTAG_AllowTAPReset = 1;                                                       // J-Link is allowed to use a TAP reset for JTAG-chain auto-detection</span><br><span class="line">  JTAG_SetDeviceId(0, 0x44770002);  // 4-bits IRLen</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /* WFI: Wait for interrupt (had to mask) */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  /* If you want to access core base address, please follow RK3288TRM v0.3 20140531 ref manual </span><br><span class="line">   * core0: 0xFFBB0000 (CPUDBG0)</span><br><span class="line">   * core1: 0xFFBB2000 (CPUDBG1)</span><br><span class="line">   * core2: 0xFFBB4000 (CPUDBG2)</span><br><span class="line">   * core3: 0xFFBB6000 (CPUDBG3)</span><br><span class="line">   */  </span><br><span class="line">  CORESIGHT_CoreBaseAddr = 0xFFBB0000;   </span><br><span class="line">  //  </span><br><span class="line">  // Manually configure which APs are present on the CoreSight device</span><br><span class="line">  //  </span><br><span class="line">  CORESIGHT_AddAP(1, CORESIGHT_AHB_AP);</span><br><span class="line">  CORESIGHT_AddAP(0, CORESIGHT_APB_AP);</span><br><span class="line">//  ResetTarget();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="http://dev.t-firefly.com/forum.php?mod=viewthread&amp;tid=2543" target="_blank" rel="noopener">firefly forum: 求助下RK3288板子的JTAG</a><br><a href="https://blog.csdn.net/groundhappy/article/details/58587912" target="_blank" rel="noopener">CSDN: rk3288的JTAG</a><br><a href="https://blog.csdn.net/hit123/article/details/5606397" target="_blank" rel="noopener">CSDN: How Jtag works</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近要在 Rockchip RK3288 上面跑 RTOS，為了讓同事可以在上面方便的除錯，我負責的部分就是要開通 RK3288 的 JTAG，並運行在 firefly-RK3288 的開發板上面&lt;br&gt;文章中說明了從 0 開始的設定過程，途中遇到的問題，以及要查找哪些資料，最後成功連線 JTAG&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Embedded Linux" scheme="https://m033010041.github.io/tags/Embedded-Linux/"/>
    
      <category term="Firefly" scheme="https://m033010041.github.io/tags/Firefly/"/>
    
      <category term="RK3288" scheme="https://m033010041.github.io/tags/RK3288/"/>
    
  </entry>
  
  <entry>
    <title>於 macOS Mojave 上建置 STM32 開發環境</title>
    <link href="https://m033010041.github.io/2019/05/20/stm32-env-macos/"/>
    <id>https://m033010041.github.io/2019/05/20/stm32-env-macos/</id>
    <published>2019-05-20T07:12:55.000Z</published>
    <updated>2019-07-27T13:47:37.381Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快速索引"><a href="#快速索引" class="headerlink" title="快速索引"></a>快速索引</h2><p>G04 主要需要 porting 兩個 phy ic 分別是</p><ul><li><a href="#安裝-Xcode">安裝 Xcode</a></li><li><a href="#安裝-port-for-macOS">安裝 port for macOS</a></li><li><a href="#建立或是選擇-toolchain-所使用的資料夾">建立或是選擇 toolchain 所使用的資料夾</a></li><li><a href="#安裝-Eclipse">安裝 Eclipse</a></li><li><a href="#安裝-Eclipse-Plugin">安裝 Eclipse Plugin</a></li><li><a href="#安裝-GNU-ARM-Plugin">安裝 GNU ARM Plugin</a></li><li><a href=""></a></li></ul><a id="more"></a><h2 id="安裝-Xcode"><a href="#安裝-Xcode" class="headerlink" title="安裝 Xcode"></a>安裝 Xcode</h2><p>使用 App store 搜尋 Xcode 後安裝即可</p><h2 id="安裝-port-for-macOS"><a href="#安裝-port-for-macOS" class="headerlink" title="安裝 port for macOS"></a>安裝 port for macOS</h2><ul><li><p>MAC port: 使用 google 搜尋 “mac port install” 或是使用<a href="https://www.macports.org/install.php" target="_blank" rel="noopener">這個安裝網址</a></p></li><li><p>點擊最新的版本進行安裝，當然要先安裝好 xcode 以及 xcode command line tools<br><img src="https://i.imgur.com/ZCnI62Q.png" alt=""></p></li><li><p>下載完後點擊 MacPorts-2.5.4-10.14-Mojave.pkg 之後一直繼續……繼續……就完成了</p></li></ul><h2 id="建立或是選擇-toolchain-所使用的資料夾"><a href="#建立或是選擇-toolchain-所使用的資料夾" class="headerlink" title="建立或是選擇 toolchain 所使用的資料夾"></a>建立或是選擇 toolchain 所使用的資料夾</h2><p>沒什麼，就是建立資料夾之後會使用<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p STM32_ToolChain</span><br></pre></td></tr></table></figure></p><p><img src="https://i.imgur.com/PnifP5y.png" alt=""></p><h2 id="安裝-Eclipse"><a href="#安裝-Eclipse" class="headerlink" title="安裝 Eclipse"></a>安裝 Eclipse</h2><ul><li>下載：<a href="https://www.eclipse.org/downloads/packages/" target="_blank" rel="noopener">https://www.eclipse.org/downloads/packages/</a></li><li>請選擇「Eclipse IDE for C/C++ Developers」—&gt; Mac Cocoa 64-bit<br><img src="https://i.imgur.com/TPG5VLk.png" alt=""></li><li>載完後點擊 .dmg file 最後只要將 icon 直接拖到 application 就完成了<br><img src="https://i.imgur.com/TiqGJA7.png" alt=""></li><li>之後打開安裝好的 eclipse</li><li>跳出 workspace 的路徑</li><li>選剛剛建立的資料夾 + project</li><li>點擊 launch<br><img src="https://i.imgur.com/uMjlKa0.png" alt=""></li></ul><h2 id="安裝-Eclipse-Plugin"><a href="#安裝-Eclipse-Plugin" class="headerlink" title="安裝 Eclipse Plugin"></a>安裝 Eclipse Plugin</h2><ul><li>Help -&gt; Install New Software<br><img src="https://i.imgur.com/FQGhQaB.png" alt=""></li><li>之後會跳出 1. 的視窗，點擊左上角 Eclipse -&gt; Perference -&gt; 會跳出 3. 的畫面，如圖<br><img src="https://i.imgur.com/xHkZXxl.png" alt=""></li><li>之後根據 3. 的視窗，點擊 Available Software Site -&gt; 然後看到打勾的三個選項有勾起來就可以了，點擊 Apply and Close 關閉<br><img src="https://i.imgur.com/kxp4UT3.png" alt=""></li><li>關閉後剩下 1. 的視窗，下拉選單點選 CDT<br><img src="https://i.imgur.com/7HAHjFe.png" alt=""></li><li>勾選的地方請打勾<br><img src="https://i.imgur.com/EIE7lN7.png" alt=""></li><li>照圖上做即可<br><img src="https://i.imgur.com/GPLjgqm.png" alt=""></li><li>挑出這個畫面後一直按 Next 就可，如果要授權就 Accept<br><img src="https://i.imgur.com/gPUAQm2.png" alt=""></li></ul><h2 id="安裝-GNU-ARM-Plugin"><a href="#安裝-GNU-ARM-Plugin" class="headerlink" title="安裝 GNU ARM Plugin"></a>安裝 GNU ARM Plugin</h2><ul><li>重新啟動後，點擊 Help -&gt; Eclipse Marketplace<br><img src="https://i.imgur.com/qSQZ7f0.png" alt=""></li><li>在 Find 的地方輸入「<strong>GNU ARM plug</strong>」，然後按下 Enter 鍵後應該會看到第一項是 GNU MCU Eclipse x.x.x，點擊 Install 安裝<br><img src="https://i.imgur.com/XIfhgz8.png" alt=""></li><li>我是怕麻煩的人，全部都裝吧！！<br><img src="https://i.imgur.com/DYZMnkq.png" alt=""></li></ul><h2 id="安裝-GCC-ARM-Embedded-Toolchain"><a href="#安裝-GCC-ARM-Embedded-Toolchain" class="headerlink" title="安裝 GCC ARM Embedded Toolchain"></a>安裝 GCC ARM Embedded Toolchain</h2><ul><li>下載網址：<a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads" target="_blank" rel="noopener">https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm/downloads</a></li><li>點選 macOS 64 bit 就可以了<br><img src="https://i.imgur.com/VumxTjz.png" alt=""></li><li>把你下載的壓縮檔案放到剛剛的 STM32_Toolchain 資料夾裡面解壓縮，壓縮檔就不要了吧<br><img src="https://i.imgur.com/D1rO8sD.png" alt=""></li></ul><h2 id="安裝-ST-LINK-upgrade-firmware"><a href="#安裝-ST-LINK-upgrade-firmware" class="headerlink" title="安裝 ST-LINK upgrade firmware"></a>安裝 ST-LINK upgrade firmware</h2><ul><li>下載網址：<a href="https://www.st.com/content/st_com/en/products/development-tools/software-development-tools/stm32-software-development-tools/stm32-programmers/stsw-link007.html" target="_blank" rel="noopener">https://www.st.com/content/st_com/en/products/development-tools/software-development-tools/stm32-software-development-tools/stm32-programmers/stsw-link007.html</a></li><li>點選下載<br><img src="https://i.imgur.com/Xn59FE1.png" alt=""></li><li>放到你喜歡的地方，然後點擊以下路徑，最後雙擊該 .jar 檔案即可<br><img src="https://i.imgur.com/wnacP66.png" alt=""></li><li>接下來要進行 stm32 firmware upgrade 了，先將裝置接上，之後點擊 1. -&gt; 2. -&gt; 3. ，然後等進度條結束就可以了<br><img src="https://i.imgur.com/gANhfcf.png" alt=""></li></ul><h2 id="安裝-OpenOCD"><a href="#安裝-OpenOCD" class="headerlink" title="安裝 OpenOCD"></a>安裝 OpenOCD</h2><ul><li>網址：<a href="https://github.com/gnu-mcu-eclipse/openocd/releases" target="_blank" rel="noopener">https://github.com/gnu-mcu-eclipse/openocd/releases</a></li><li>可以使用 git 來進行下載與安裝，但我們這次使用手動的方式，在下載網址中找到 assets 之後下載 macOS 專用的 packages<br><img src="https://i.imgur.com/X7otD9L.png" alt=""></li><li>之後隨意解壓縮，然後將目標的資料夾移到之前我們創建的 STM32_ToolChain 資料夾中</li><li><img src="https://i.imgur.com/0JMnEDa.png" alt=""></li><li>之後開啟終端機，輸入以下指令<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/STM32_ToolChain/openocd/scripts</span><br><span class="line">../bin/openocd -f board/stm32f469discovery.cfg</span><br></pre></td></tr></table></figure></li></ul><p>不能看到 error 就完成了</p><p>如果還有其他需要安裝的 Toolchain 會記錄在此</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;快速索引&quot;&gt;&lt;a href=&quot;#快速索引&quot; class=&quot;headerlink&quot; title=&quot;快速索引&quot;&gt;&lt;/a&gt;快速索引&lt;/h2&gt;&lt;p&gt;G04 主要需要 porting 兩個 phy ic 分別是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#安裝-Xcode&quot;&gt;安裝 Xcode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#安裝-port-for-macOS&quot;&gt;安裝 port for macOS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#建立或是選擇-toolchain-所使用的資料夾&quot;&gt;建立或是選擇 toolchain 所使用的資料夾&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#安裝-Eclipse&quot;&gt;安裝 Eclipse&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#安裝-Eclipse-Plugin&quot;&gt;安裝 Eclipse Plugin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#安裝-GNU-ARM-Plugin&quot;&gt;安裝 GNU ARM Plugin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="STM32" scheme="https://m033010041.github.io/tags/STM32/"/>
    
      <category term="STM32F4" scheme="https://m033010041.github.io/tags/STM32F4/"/>
    
      <category term="macOS" scheme="https://m033010041.github.io/tags/macOS/"/>
    
      <category term="Environment" scheme="https://m033010041.github.io/tags/Environment/"/>
    
  </entry>
  
  <entry>
    <title>[udhcpc] busybox udhcpc 功能討論</title>
    <link href="https://m033010041.github.io/2019/04/20/udhcpc-option/"/>
    <id>https://m033010041.github.io/2019/04/20/udhcpc-option/</id>
    <published>2019-04-20T12:59:18.000Z</published>
    <updated>2019-07-28T14:41:12.727Z</updated>
    
    <content type="html"><![CDATA[<p>其實 busybox udhcpc 可以實現許多很實用的功能，例如</p><ul><li>定時更新 IP 與租約</li><li>背景執行 (與 linux 背警執行的 &amp; 不同，要看其他 option 來做變化)</li><li>立即取得租約</li><li>可以控制 udhcpc 本身 process 的運作<a id="more"></a></li></ul><p>我們可以先看 busybox 的 udhcpc help options<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[root@cMT-3E8D /root]<span class="comment"># udhcpc --help</span></span><br><span class="line">BusyBox v1.20.2 (2014-05-26 18:14:32 CST) multi-call binary.</span><br><span class="line"></span><br><span class="line">Usage: udhcpc [-fbnqvoCRB] [-i IFACE] [-r IP] [-s PROG] [-p PIDFILE]</span><br><span class="line">    [-V VENDOR] [-x OPT:VAL]... [-O OPT]...</span><br><span class="line"></span><br><span class="line">    -i,--interface IFACE    Interface to use (default eth0)</span><br><span class="line">    -p,--pidfile FILE    Create pidfile</span><br><span class="line">    -s,--script PROG    Run PROG at DHCP events (default /usr/share/udhcpc/default.script)</span><br><span class="line">    -B,--broadcast        Request broadcast replies</span><br><span class="line">    -t,--retries N        Send up to N discover packets</span><br><span class="line">    -T,--timeout N        Pause between packets (default 3 seconds)</span><br><span class="line">    -A,--tryagain N        Wait N seconds after failure (default 20)</span><br><span class="line">    -f,--foreground        Run <span class="keyword">in</span> foreground</span><br><span class="line">    -b,--background        Background <span class="keyword">if</span> lease is not obtained</span><br><span class="line">    -n,--now        Exit <span class="keyword">if</span> lease is not obtained</span><br><span class="line">    -q,--quit        Exit after obtaining lease</span><br><span class="line">    -R,--release        Release IP on <span class="built_in">exit</span></span><br><span class="line">    -S,--syslog        Log to syslog too</span><br><span class="line">    -a,--arping        Use arping to validate offered address</span><br><span class="line">    -O,--request-option OPT    Request option OPT from server (cumulative)</span><br><span class="line">    -o,--no-default-options    Don<span class="string">'t request any options (unless -O is given)</span></span><br><span class="line"><span class="string">    -r,--request IP        Request this IP address</span></span><br><span class="line"><span class="string">    -x OPT:VAL        Include option OPT in sent packets (cumulative)</span></span><br><span class="line"><span class="string">                Examples of string, numeric, and hex byte opts:</span></span><br><span class="line"><span class="string">                -x hostname:bbox - option 12</span></span><br><span class="line"><span class="string">                -x lease:3600 - option 51 (lease time)</span></span><br><span class="line"><span class="string">                -x 0x3d:0100BEEFC0FFEE - option 61 (client id)</span></span><br><span class="line"><span class="string">    -F,--fqdn NAME        Ask server to update DNS mapping for NAME</span></span><br><span class="line"><span class="string">    -V,--vendorclass VENDOR    Vendor identifier (default '</span>udhcp VERSION<span class="string">')</span></span><br><span class="line"><span class="string">    -C,--clientid-none    Don'</span>t send MAC as client identifier</span><br><span class="line">    -v            Verbose</span><br><span class="line">Signals:</span><br><span class="line">    USR1    Renew lease</span><br><span class="line">    USR2    Release lease</span><br></pre></td></tr></table></figure></p><p>我們針對這幾個選項做討論好了，其他的可以去看 udhcpc 的 man page 獲得更多的訊息與使用方式</p><ul><li><code>-i IFACE</code>: 選定 udhcpc 所要使用的網路介面<ul><li>usage: <code>udhcpc -i wlan0</code> (假設是使用 wifi 介面)</li><li>可以針對不同的網路介面去取得 dhcp server 所配給的 ip address</li></ul></li><li><code>-p PIDFILE</code>: 當 udhcpc 執行後有保留其 process 的時候，建立 udhcpc pid file<ul><li>usage: <code>udhcpc -i eth0 -p /var/run/udhcpc-eth0.pid</code></li><li>可以保存其 pid file 並透過 pid 相關的控制指令去控制其 pid file，例如 kill 指令 (kill 不單單是可以殺掉 process 也可以傳輸 signal)</li></ul></li><li><code>-s SCRIPT_PATH</code>: 可以使用特定的 udhcpc 腳本<ul><li>usage: <code>udhcpc -i eth0 -s /etc/udhcpc_special.script</code></li><li>因為有時候會針對不同的介面去跑不同的腳本，而腳本的討論會在這個文章中做說明(等更新時連結會附上)</li><li>預設的腳本路徑是 <code>/usr/share/udhcpc/default.script</code> 當沒有這個檔案應該沒辦法跑 udhcpc，所以這個腳本一定要有，不帶參數的時候就是跑這個腳本</li></ul></li><li><code>-t RETRY_NUM</code>: 指定取得 dhcp reply 的次數<ul><li>usage: <code>udhcpc -i eth0 -t 3</code></li><li><code>RETRY_NUM</code> 表示當 udhcpc 要不到 dhcp reply 的時候還會執行的次數 (實際上是 <code>RETRY_NUM-1</code>)</li><li>當成功要到 ip address 就不會再發送後續次數的封包</li></ul></li><li><code>-T TIMEOUT</code>: 設定 dhcp reply 回覆的等待時間<ul><li>預設是三秒</li><li>如果三秒等待不到 reply packet 就會進入後續動作 (若有 <code>-q</code> 就離開，有 <code>-t 3</code> 就會繼續發 request 封包)</li></ul></li><li><code>-A AFTER_N_SECS</code>: 若 dhcp 失敗後，等待 <code>AFTER_N_SECS</code> 後再執行一次相同動作<ul><li>usage: <code>udhcpc -i eth0 -A 60</code>，表示失敗後等待 60 s 再次執行 <code>udhcpc -i eth0 -A 60</code></li><li><code>-A</code> 通常要配 <code>-b</code> 或是 <code>-p</code>，在背景執行時失敗後會重新執行 udhcpc</li><li>這個跟 <code>-t RETRY_NUM</code> 不一樣，-A 是當程式真的認為已經進入了 dhcp failure 的狀態的時候會等待一段時間後再執行 udhcpc，而 -t 次數都結束且都沒有要到 ip address 的時候才會認定是 dhcp failure</li><li>預設是 20 s</li></ul></li><li><code>-f/-b</code>: process 執行的位置 foreground / background<ul><li>usage: <code>udhcpc -i eth0 -f</code> / <code>udhcpc -i eth0 -b</code></li><li><code>-b</code> 比較特殊，<code>-b</code> 是當封包沒有要到的時候會自動進入背景，此時 process 不會消失，可以使用 <code>kill()</code> 傳送 signal 給 udhcpc process</li></ul></li><li><code>-n</code>: 當沒有要到 ip address 的時候離開 process<ul><li>usage: <code>udhcpc -i eth0 -n</code></li><li><code>-b</code> 與 <code>-n</code> 不要同時存在，一個是沒要到會進入背景執行，另一個是沒要到會刪掉 process，如果兩個同時存在時，我試過 <code>-n</code> 的 priority 比較高，<code>-b</code> 沒有意義</li></ul></li><li><code>-q</code>: 當要到 ip address 的時候離開<ul><li>usage: <code>uchcpc -i eth0 -q</code> </li><li>這個在一些特殊的地方會用到，通常當你要到 ip address 之後不會想要針對 process 進行處置的時候可以用此 option</li><li>若你只是想要從網域中發送 dhcp 封包並且獲得一個合理的回覆，但並不會想要對此封包做任何處置用這個指令也很適合</li></ul></li><li><code>-R</code>: 當 process 被殺掉的時候執行 release request<ul><li>usage: <code>udhcpc -i eth0 -R</code> </li><li>這個算是蠻重要的一環，但也相對要小心使用，因為這樣才可以保證網域內的網路分配是可以循環使用的，不然通常沒有加上 <code>-R</code> 的 udhcpc 離開時，dhcp server 並不知道，導致此 ip address 一直被這個 mac 所佔用，要等到 86400 秒租約過期後才會釋出</li></ul></li></ul><h2 id="關於-udhcpc-signal-的討論-SIGUSR1-SIGUSR2"><a href="#關於-udhcpc-signal-的討論-SIGUSR1-SIGUSR2" class="headerlink" title="關於 udhcpc signal 的討論 (SIGUSR1/SIGUSR2)"></a>關於 udhcpc signal 的討論 (<code>SIGUSR1/SIGUSR2</code>)</h2><ul><li>關於狀態機的討論，請看這個文章(等更新後會附上)</li><li><code>SIGUSR1 (10)</code>: 目的是強制執行 renew 狀態，狀態機會跳到 <code>RENEW_REQUESTED</code>，但是等同於 <code>RENEW</code> 狀態，之後自動進入 <code>REBINDING</code> 狀態並且發送 <code>DHCPREQUEST</code> packet<br>之後會運行 <code>timeout &gt;&gt; 1</code> 直到 <code>timeout &lt;=0</code> 為止，總共花了約 50s 才發生 timeout 回到 INIT 狀態並且 script run deconfig</li><li><code>SIGYSR2 (12)</code>: 目的是強制 release 現在的 lease，並將狀態強制進到 <code>RELEASED</code> 狀態，此狀態在 udhcpc source code並沒有任何功能，就是一個 idle status，但是如果收到 <code>SIGUSR1</code> 的訊號時，就會立即將狀態回到 <code>INIT</code> 狀態</li></ul><p>由以上的討論，如果要將 udhcpc 設成 daemon 的話，最好的方式就是執行<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pid = check_pid(<span class="string">"/var/run/udhcpc-eth0.pid"</span>);</span><br><span class="line">kill(SIGUSR2, pid); <span class="comment">// set udhcpc to release state</span></span><br><span class="line">kill(SIGUSR1, pid); <span class="comment">// set udhcpc to init state and get lease again</span></span><br></pre></td></tr></table></figure></p><h2 id="實際-udhcpc-指令的使用方式"><a href="#實際-udhcpc-指令的使用方式" class="headerlink" title="實際 udhcpc 指令的使用方式"></a>實際 udhcpc 指令的使用方式</h2><p>我們直接用 bash 的指令直接說明，以下是我在公司工作時被要求需要達到的網路功能</p><ol><li>希望網路要到的時候會產生一個 pid file: <code>/var/run/udhcpc-&lt;IFACE&gt;.pid</code></li><li>希望可以發送三次 udhcpc 的 requeset 封包 (實驗過後覺得發送三次最適當)</li><li>希望沒有要到的時候可以每 60 秒嘗試再要一次 ip address</li></ol><p>就以上三點，我們可以直接使用剛剛提到的 option 組合來實現：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">udhcpc -i &lt;IFACE&gt; -p /var/run/udhcpc-eth0.pid -b -t 3 -A 60</span><br></pre></td></tr></table></figure></p><p>理論上要不到 ip，會進入背景，並且 hang 60 sec 之後才會再丟 3 次 discover 封包，若可以要到的話，就可以直接要到 IP，daemon 還是會存在，若要不到的話，會重新計數 retry 時間，然後 60s 後自動要到 ip address</p><p>這篇結束後，我們將會討論 udhcpc 所使用的 script 的結構與設計方式</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其實 busybox udhcpc 可以實現許多很實用的功能，例如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定時更新 IP 與租約&lt;/li&gt;
&lt;li&gt;背景執行 (與 linux 背警執行的 &amp;amp; 不同，要看其他 option 來做變化)&lt;/li&gt;
&lt;li&gt;立即取得租約&lt;/li&gt;
&lt;li&gt;可以控制 udhcpc 本身 process 的運作&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Embedded Linux" scheme="https://m033010041.github.io/tags/Embedded-Linux/"/>
    
      <category term="busybox" scheme="https://m033010041.github.io/tags/busybox/"/>
    
      <category term="udhcpc" scheme="https://m033010041.github.io/tags/udhcpc/"/>
    
      <category term="network" scheme="https://m033010041.github.io/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>The Linux Programming Interface : Chapter 25: 終止行程</title>
    <link href="https://m033010041.github.io/2019/01/15/TLPI-ExitProcess/"/>
    <id>https://m033010041.github.io/2019/01/15/TLPI-ExitProcess/</id>
    <published>2019-01-15T08:58:41.000Z</published>
    <updated>2019-07-28T14:18:35.398Z</updated>
    
    <content type="html"><![CDATA[<p>本章節介紹如下</p><ol><li>介紹如何使用 <code>exit()</code> 以及 <code>_exit()</code> 結束行程</li><li>探討行程在呼叫 <code>exit()</code> 函式時，會使用結束處理常式 <em>exit handler</em> 進行自動管理</li><li>探討 <code>fork()</code>、<code>stdio</code>緩衝區，以及<code>exit()</code>之間的互動</li></ol><a id="more"></a><h2 id="25-1-終止行程：-exit-與-exit"><a href="#25-1-終止行程：-exit-與-exit" class="headerlink" title="25.1 終止行程： exit() 與 _exit()"></a>25.1 終止行程： <code>exit()</code> 與 <code>_exit()</code></h2><h3 id="exit-：終止行程的-system-call"><a href="#exit-：終止行程的-system-call" class="headerlink" title="_exit()：終止行程的 system call"></a><code>_exit()</code>：終止行程的 system call</h3><p>有兩種方式可以終止行程</p><ul><li>異常終止(abnormal)：如 20.1 節所描述，由訊號 signal 觸發，預設訂做是終止行程，可產生核心傾印檔 (core dump file)</li><li>使用 <code>_exit()</code> 系統呼叫將行程正常終止</li></ul><h4 id="function-declare"><a href="#function-declare" class="headerlink" title="function declare:"></a>function declare:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _exit(<span class="keyword">int</span> status);</span><br></pre></td></tr></table></figure><h4 id="status-的討論"><a href="#status-的討論" class="headerlink" title="status 的討論"></a>status 的討論</h4><ul><li>status 參數定義形成的終止狀態(termination status)，父行程可以呼叫 wait() 取得該狀態，雖然型別定義為 <code>int</code>，但實際上服行程只能取得 status 參數的 <strong>後 8 個位元</strong>。</li><li>依據慣例：<ul><li>結束狀態為 0 表示行程順利結束</li><li>非 0 的狀態則表示行程異常終止</li></ul></li><li>目前對於如何解釋非零的狀態並無固定規則，不同的應用程式有自家慣例可以遵循</li><li>書中大多數的程式都是遵循 <code>SUSv3</code> 制訂的兩個常數<ul><li><code>EXIT_SUCCESS(0)</code></li><li><code>EXIT_FAILURE(1)</code></li></ul></li></ul><blockquote><p><strong>行程一定可以藉由 <code>_exit()</code> 順利終止 (即呼叫 <code>_exit()</code> 之後不會繼續執行)</strong></p><p>雖然 status 可以透過 0-255 之間的任意值傳遞給父行程，但若將 status 的數值設定大於 128 ，則會在 shell 腳本產生混淆，原因在於若指令是經由訊號終止的，則 shell 會將 <code>$?</code> 變數值設定為 128 加上訊號編號來表示現實情況，當行程用一樣的 status 的數值呼叫 <code>_exit()</code> 時會無法分辨。</p></blockquote><h3 id="exit-：較常使用的函式庫函式-並非-system-call"><a href="#exit-：較常使用的函式庫函式-並非-system-call" class="headerlink" title="exit()：較常使用的函式庫函式 (並非 system call)"></a><code>exit()</code>：較常使用的函式庫函式 (並非 system call)</h3><p>通常不會直接呼叫 <code>_exit()</code>，而是呼叫 <code>exit()</code> 函式庫函式，此函式可在呼叫 <code>_exit()</code> 之前執行一些動作</p><h4 id="function-declare-1"><a href="#function-declare-1" class="headerlink" title="function declare"></a>function declare</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br></pre></td></tr></table></figure><p>或是輸入 <code>man exit</code> 取得更詳細的說明</p><h3 id="exit-的執行動作"><a href="#exit-的執行動作" class="headerlink" title="exit() 的執行動作"></a><code>exit()</code> 的執行動作</h3><p>會進行下列動作</p><ul><li>以反向註冊程序 (ch25.3)，呼叫 Exit 處理常式 (<code>atexit()</code>與<code>on_exit()</code>註冊的函式)</li><li>flush stdio 串流緩衝區</li><li>使用 status 提供的值執行 <code>_exit()</code> 系統呼叫</li></ul><h4 id="exit-的討論"><a href="#exit-的討論" class="headerlink" title="exit() 的討論"></a><code>exit()</code> 的討論</h4><ul><li><code>exit()</code> 與 <code>_exit()</code> 不同點：<code>_exit</code> 是 UNIX 特有的，而 <code>exit()</code> 是 libc 的 funciton，簡單說任何 C 語言實作都可以使用 exit()</li><li>在 <code>main()</code> 中執行 <code>return</code> 是對等的，<code>return n</code> 等同於執行<code>exit(n)</code></li><li>有一種情況，呼叫 <code>exit()</code> 會從 <code>main return</code> 會不等價<ul><li>using <code>setvbuf()</code> or <code>setbuf</code> 時使用 <code>main()</code> 的區域變數時 (ch13.2)</li></ul></li></ul><h2 id="25-2-細說行程的終止"><a href="#25-2-細說行程的終止" class="headerlink" title="25.2 細說行程的終止"></a>25.2 細說行程的終止</h2><h3 id="行程終止的過程"><a href="#行程終止的過程" class="headerlink" title="行程終止的過程"></a>行程終止的過程</h3><p>終止過程中，會有下列動作：</p><ul><li>close descriptors (ch18.8)<ul><li>open file descriptors</li><li>directory stream</li><li>message catalog descriptor</li><li>conversion descriptor</li></ul></li><li>close file lock of the process (ch55)</li><li>unattached System V share memory block (ch48.8)</li><li>對於行程已設定 semadj 值的每個 semaphore，會將 semadj 值加到 semaphore 的值 (ch 47.8)</li><li>若為 controlling terminal 的 controlling process，則會將 <code>SIGHUP</code> 訊號傳給每個行程的控制終端機的 foreground process gruop，並移除 termnal 與 session 的關聯 (ch34.6)</li><li>呼叫類似 <code>sem_close()</code> 的方式關閉 semaphore</li><li>呼叫類似 <code>mq_close()</code> 的方式關閉 message queue</li><li>此行程結束會使得此行程孤立狀態，群組中每個行程都會收到 <code>SIGHUP</code> 訊號，並接著收到 <code>SIGCONT</code> 訊號 (ch34.7.4)</li><li>移除使用 <code>mlock()</code> and <code>mlockall()</code> 所建立的 memory lock (ch50.2)</li><li>移除此行程使用 <code>mmap()</code> 建立的記憶體映射</li></ul><h2 id="25-3-結束處理常式-Exit-Handler"><a href="#25-3-結束處理常式-Exit-Handler" class="headerlink" title="25.3 結束處理常式 (Exit Handler)"></a>25.3 結束處理常式 (Exit Handler)</h2><p>應用程式有時要在行程結束時自動執行一些操作，以應用程式的函式庫為例，若在行程的生命週期期間有用到函式庫，則當該行程離開時，需要進行一些自動清理動作。因為函式庫無法掌控行程何時結束，也不能授權主程式在結束之前一定要呼叫一個函式庫指定的清理函式，這樣就不能保證行程結束時會做清理動作。</p><p>因此使用結束處理常式，在 System V 所使用的術語是<strong>程式終止常式 (program termination routine)</strong></p><p>結束處理常式</p><ul><li>通常是由程式設計是提供的函式</li><li>在行程的生命週期內在一些位址上註冊</li><li>在行程<strong>進行正常終止</strong>期間透過 <code>exit()</code> 自動呼叫</li><li>若程式直接呼叫 <code>_exit()</code> 則不會呼叫 Exit Handler</li><li>以信號 (signal) 終止行程並不會呼叫 Exit Handler<ul><li>所以最佳的作法就是盡可能幫行程收到的訊號建立 Exit Handler</li><li>但是依舊無法處理 <code>SIGKILL</code></li><li>因此使用者要避免使用 <code>SIGKILL</code> 並改用 <code>SIGTERM</code></li></ul></li></ul><h3 id="註冊-Exit-Handler"><a href="#註冊-Exit-Handler" class="headerlink" title="註冊 Exit Handler"></a>註冊 Exit Handler</h3><h4 id="function-declare-2"><a href="#function-declare-2" class="headerlink" title="function declare"></a>function declare</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns 0 on success, or nonzero on error */</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atexit</span><span class="params">(<span class="keyword">void</span> (*func)(<span class="keyword">void</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>由定義中的 function pointer 我們可以知道</p><ul><li>函式不應該傳遞參數</li><li><p>函式不應該有回傳值</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* progress */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>atexit()</code> 在出錯時會傳回「非零值」(不一定是 -1)</p></li><li>一個行程可以註冊多個 Exit Handler，甚至可以多次註冊相同的 Exit Handler</li><li>在程式呼叫 <code>exit()</code> 時，呼叫這些函式的順序會與註冊時相反</li><li><p>簡單的例子</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* atexit example */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;      /* puts */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;     /* atexit */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fnExit1</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">puts</span> (<span class="string">"Exit function 1."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fnExit2</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">puts</span> (<span class="string">"Exit function 2."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  atexit (fnExit1);</span><br><span class="line">  atexit (fnExit2);</span><br><span class="line">  <span class="built_in">puts</span> (<span class="string">"Main function."</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  最後的結果為</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ /tmp/<span class="built_in">test</span>   </span><br><span class="line">Main <span class="keyword">function</span>.</span><br><span class="line">Exit <span class="keyword">function</span> 2.</span><br><span class="line">Exit <span class="keyword">function</span> 1.</span><br></pre></td></tr></table></figure></li><li><p>若某個 Exit Handler 呼叫了 <code>_exit()</code> 或是收到了訊號終止，則不會繼續呼叫剩餘的 Exit Handler</p></li><li>若 Exit Handler 自己呼叫 <code>exit()</code> ，則會有不可預期的後果，應避免在 Exit Handler 中使用 <code>exit()</code><ul><li>Linux 會繼續呼叫剩餘的 Exit Handler</li><li>有些系統會進入遞迴，直到 stack overflow 後才終止</li></ul></li><li>SUSv3 要求系統要能讓一個行程<strong>至少可註冊 32 個</strong> Exit Handler，在 Linux 若使用 <code>sysconf(_SC_ATEXIT_MAX);</code> 則會 return <code>2,147,483,647</code> ，換句話說，可能未到達上限之前，記憶體就不足導致問題發生了</li><li>透過 <code>fork()</code> 建立的 child process 會繼承 parent process 的註冊 Exit Handler 複本</li><li><code>atexit()</code> 的兩個限制<ul><li><code>atexit()</code> 無法傳遞狀態給 <code>exit()</code>。有時候狀態是必要的</li><li>無法給 Exit Handler 傳遞參數，這樣表示只能透過全域變數旗標來區分 Exit Handler 較細部的動作</li></ul></li></ul><p>為了擺脫上述的限制，glibc 提供了一個非標準替代方法：<code>on_exit()</code></p><h3 id="on-exit-的討論"><a href="#on-exit-的討論" class="headerlink" title="on_exit() 的討論"></a><code>on_exit()</code> 的討論</h3><h4 id="on-exit-function-declare"><a href="#on-exit-function-declare" class="headerlink" title="on_exit() function declare"></a><code>on_exit()</code> function declare</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return 0 on success, or nonzero on error */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">on_exit</span><span class="params">(<span class="keyword">void</span> (*func)(<span class="keyword">int</span>, <span class="keyword">void</span>*), <span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>由以上，我們可以知道 <code>on_exit()</code> 所註冊的函式要依循</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> status, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Perform cleanup actions */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>void *arg</code> 這個參數可以帶入各種型態，或是使用轉型(cast)，傳入純量</p><ul><li><code>on_exit(onExitFunc, (void *)10);</code></li></ul></li><li>Example  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (on_exit(onexitFunc, (<span class="keyword">void</span> *) <span class="number">10</span>) != <span class="number">0</span>)</span><br><span class="line">        fatal(<span class="string">"on_exit 1"</span>);</span><br><span class="line">    <span class="keyword">if</span> (atexit(atexitFunc1) != <span class="number">0</span>)</span><br><span class="line">        fatal(<span class="string">"atexit 1"</span>);</span><br><span class="line">    <span class="keyword">if</span> (atexit(atexitFunc2) != <span class="number">0</span>)</span><br><span class="line">        fatal(<span class="string">"atexit 2"</span>);</span><br><span class="line">    <span class="keyword">if</span> (on_exit(onexitFunc, (<span class="keyword">void</span> *) <span class="number">20</span>) != <span class="number">0</span>)</span><br><span class="line">        fatal(<span class="string">"on_exit 2"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="25-4-fork-stdio-buffer-與-exit-之間的關係"><a href="#25-4-fork-stdio-buffer-與-exit-之間的關係" class="headerlink" title="25.4 fork(), stdio buffer 與 _exit() 之間的關係"></a>25.4 fork(), stdio buffer 與 <code>_exit()</code> 之間的關係</h2><h3 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello world\n"</span>);</span><br><span class="line">    write(STDOUT_FILENO, <span class="string">"Ciao\n"</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">"fork"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Both child and parent continue execution here */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="執行結果"><a href="#執行結果" class="headerlink" title="執行結果"></a>執行結果</h3><p>分成兩部分</p><ul><li>直接透過 terminal 輸出</li><li>導入至文件</li></ul><h3 id="分析為何會輸出兩次："><a href="#分析為何會輸出兩次：" class="headerlink" title="分析為何會輸出兩次："></a>分析為何會輸出兩次：</h3><ul><li><code>printf()</code> 是一個緩衝輸出函式，由 glibc 所提供，為一個標準函式而非系統調用</li><li><code>printf()</code> 對於 FILE I/O 的 FILE stream，需要滿足以下才會從緩衝區輸出至文件<ul><li>緩衝區已滿</li><li>寫入的字元含有 ‘\n’ ‘\r’</li><li>調用 <code>fflush()</code> 清空緩衝區</li><li>調用 <code>scanf()</code> 要從緩衝區讀取內容時</li></ul></li><li>因此 <code>fork()</code> 後就會將緩衝區複製一份</li><li>調用 <code>exit()</code> 的時候 parent/child process 就會各自清空自己的緩衝區</li></ul><p>因此我們可以使用兩種方式處理</p><ol><li>使用 <code>fflush()</code> 或是 <code>setvbuf()</code> 來清空、設定緩衝區<ul><li><a href="http://www.cplusplus.com/reference/cstdio/fflush/" target="_blank" rel="noopener">fflush</a></li><li><a href="https://en.cppreference.com/w/c/io/setvbuf" target="_blank" rel="noopener">setvbuf</a></li></ul></li><li>子行程調用 <code>_exit()</code> 而非 <code>exit()</code><ul><li>設計通用原則：父行程調用 <code>exit()</code>，由父行程產生的子行程則是調用 <code>_exit()</code> 從而確保只有一個進程調用 Exit Handler 並刷新 stdio buffer</li></ul></li></ol><h3 id="分析為何-write-會優先執行"><a href="#分析為何-write-會優先執行" class="headerlink" title="分析為何 write() 會優先執行"></a>分析為何 <code>write()</code> 會優先執行</h3><p>因為 <code>write()</code> 是系統調用，所以會直接輸出到 kerenl space 的緩衝區，而 printf() 是 user space 的緩衝區</p><h2 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h2><h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><p>如果 <code>fork()</code> 出的子行程執行 exit(-1)，父程序會收到哪個數值 (使用 <code>WEXITSTATUS</code> 回傳)</p><h3 id="Answer"><a href="#Answer" class="headerlink" title="Answer"></a>Answer</h3><h4 id="Practice-code"><a href="#Practice-code" class="headerlink" title="Practice code"></a>Practice code</h4><p>我最後練習的程式碼如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//atexit(end);</span></span><br><span class="line"></span><br><span class="line">        pid = fork();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Child: This is the CHILD ID = %d\n"</span>, getpid());</span><br><span class="line">                <span class="keyword">while</span> (c &lt; <span class="number">5</span>) &#123;</span><br><span class="line">                        sleep(<span class="number">1</span>);</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"CHLID TIMER: %d\n"</span>,c);</span><br><span class="line">                        c++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Child is over..\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"This is parent process, pid = %d\n"</span>, getpid());</span><br><span class="line">                sleep(<span class="number">3</span>);</span><br><span class="line">                wait(&amp;status);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Parent: status = %d\n"</span>, status);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Parent: WEXITSTATUS(status) = %d\n"</span>, WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="執行結果-1"><a href="#執行結果-1" class="headerlink" title="執行結果"></a>執行結果</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">weintek-timmy@weintek-timmy:~/Timmy/presentation/tlpi_chapter25$ !gcc</span><br><span class="line">gcc -o <span class="built_in">test</span> test.c</span><br><span class="line">weintek-timmy@weintek-timmy:~/Timmy/presentation/tlpi_chapter25$ ./<span class="built_in">test</span></span><br><span class="line">This is parent process, pid = 12279</span><br><span class="line">Child: This is the CHILD ID = 12280</span><br><span class="line">Child is over..</span><br><span class="line">Parent: status = 65280</span><br><span class="line">Parent: WEXITSTATUS(status) = 255</span><br></pre></td></tr></table></figure><h4 id="結果分析"><a href="#結果分析" class="headerlink" title="結果分析"></a>結果分析</h4><p>我們先來看 <a href="http://man7.org/linux/man-pages/man2/waitpid.2.html" target="_blank" rel="noopener"><code>wait()</code></a> 到底做了些什麼？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WEXITSTATUS(wstatus);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  returns the exit status of the child.  This consists of the</span></span><br><span class="line"><span class="comment"> *  least significant 8 bits of the status argument that the child</span></span><br><span class="line"><span class="comment"> *  specified in a call to exit(3) or _exit(2) or as the argument</span></span><br><span class="line"><span class="comment"> *  for a return statement in main().  This macro should be</span></span><br><span class="line"><span class="comment"> *  employed only if WIFEXITED returned true.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>很合理，只看最後 8 bit，也就是 255，所以 <code>WEXITSTATUS(status)</code></p><h4 id="status-的討論-1"><a href="#status-的討論-1" class="headerlink" title="status 的討論"></a>status 的討論</h4><p>其實討論 status 用此方式，似乎不是很合理，畢竟在子行程調用 <code>exit(-1)</code> 有點奇怪，不過我試了一下，Linux 似乎會將 <code>exit()</code> 的值左移 8 bit，也就是 status * 256</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        pid = fork();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Child: This is the CHILD ID = %d\n"</span>, getpid());</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Child is over..\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"This is parent process, pid = %d\n"</span>, getpid());</span><br><span class="line">                wait(&amp;status);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Parent: status = %d\n"</span>, status);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Parent: WEXITSTATUS(status) = %d\n"</span>, WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>結果如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">weintek-timmy@weintek-timmy:~/Timmy/presentation/tlpi_chapter25$ ./<span class="built_in">test</span></span><br><span class="line">This is parent process, pid = 13677</span><br><span class="line">Child: This is the CHILD ID = 13678</span><br><span class="line">Child is over..</span><br><span class="line">Parent: status = 256</span><br><span class="line">Parent: WEXITSTATUS(status) = 1</span><br></pre></td></tr></table></figure><p>這部分我還要找些資料才會知道，不過可以確認的是，必須使用 <code>WEXITSTATUS()</code> 才能正確收到 child process 真正 return 的值</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://stackoverflow.com/questions/13328332/waitpid-wrong-usage" target="_blank" rel="noopener">https://stackoverflow.com/questions/13328332/waitpid-wrong-usage</a></li><li><a href="https://stackoverflow.com/questions/26435730/forked-child-exits-with-1-but-wexitstatus-gets-255" target="_blank" rel="noopener">https://stackoverflow.com/questions/26435730/forked-child-exits-with-1-but-wexitstatus-gets-255</a></li><li><a href="https://stackoverflow.com/questions/52731842/how-to-get-the-return-value-of-child-process-to-its-parent-which-was-created-usi" target="_blank" rel="noopener">https://stackoverflow.com/questions/52731842/how-to-get-the-return-value-of-child-process-to-its-parent-which-was-created-usi</a></li><li><a href="https://en.cppreference.com/w/c/io/setvbuf" target="_blank" rel="noopener">https://en.cppreference.com/w/c/io/setvbuf</a></li><li><a href="http://www.cplusplus.com/reference/cstdlib/atexit/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/cstdlib/atexit/</a></li><li><a href="http://man7.org/linux/man-pages/man2/waitpid.2.html" target="_blank" rel="noopener">http://man7.org/linux/man-pages/man2/waitpid.2.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章節介紹如下&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;介紹如何使用 &lt;code&gt;exit()&lt;/code&gt; 以及 &lt;code&gt;_exit()&lt;/code&gt; 結束行程&lt;/li&gt;
&lt;li&gt;探討行程在呼叫 &lt;code&gt;exit()&lt;/code&gt; 函式時，會使用結束處理常式 &lt;em&gt;exit handler&lt;/em&gt; 進行自動管理&lt;/li&gt;
&lt;li&gt;探討 &lt;code&gt;fork()&lt;/code&gt;、&lt;code&gt;stdio&lt;/code&gt;緩衝區，以及&lt;code&gt;exit()&lt;/code&gt;之間的互動&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="The Linux Programming Interface" scheme="https://m033010041.github.io/tags/The-Linux-Programming-Interface/"/>
    
      <category term="Linux" scheme="https://m033010041.github.io/tags/Linux/"/>
    
      <category term="讀書心得" scheme="https://m033010041.github.io/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>[Embedded linux] SNMP 移植完整教程</title>
    <link href="https://m033010041.github.io/2018/12/06/build-arm-net-snmp-guide/"/>
    <id>https://m033010041.github.io/2018/12/06/build-arm-net-snmp-guide/</id>
    <published>2018-12-05T16:45:25.000Z</published>
    <updated>2018-12-05T16:53:08.556Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>目前我的想法是</p><ol><li>先找 snmp packages 並嘗試透過 cross-compiler build snmp packages</li><li>使用 pc build 一版 x86 版本的 snmpd</li><li>學習 PC 如何透過 snmp client 來驗證 snmpd</li></ol><p>本文目前只有詳細介紹第1點</p><a id="more"></a><h2 id="snmp-for-arm-linux-platform"><a href="#snmp-for-arm-linux-platform" class="headerlink" title="snmp for arm-linux platform"></a>snmp for arm-linux platform</h2><h3 id="準備工作"><a href="#準備工作" class="headerlink" title="準備工作"></a>準備工作</h3><ol><li>下載 net-snmp 5.8 source code package</li><li>透過 cross-compiler build snmpd binary</li><li>學習 snmpd.conf 的設定</li><li>移植到 arm-linux 進行測試</li><li>遇到問題與除錯方法</li><li>使用 snmp client 來驗證正確</li></ol><h3 id="1-下載-net-snmp-5-8-source-code-package"><a href="#1-下載-net-snmp-5-8-source-code-package" class="headerlink" title="1. 下載 net-snmp 5.8 source code package"></a>1. 下載 net-snmp 5.8 source code package</h3><ul><li>到下載頁面：<a href="http://www.net-snmp.org/download.html" target="_blank" rel="noopener">http://www.net-snmp.org/download.html</a></li><li>目前版本到達 <code>v5.8</code>，也可下載 Long Term Support (LTS) 版本 <code>v5.7.3</code></li><li>我們這次使用 <code>v5.8</code> 作為目標版本</li></ul><h3 id="2-透過-cross-compiler-build-snmpd-binary"><a href="#2-透過-cross-compiler-build-snmpd-binary" class="headerlink" title="2. 透過 cross-compiler build snmpd binary"></a>2. 透過 cross-compiler build snmpd binary</h3><p>目前我參考的 porting 網站有許多，覺得<a href="https://www.cnblogs.com/quliuliu2013/p/7520241.html" target="_blank" rel="noopener">這個最好</a></p><h4 id="configure-的-option"><a href="#configure-的-option" class="headerlink" title="configure 的 option"></a>configure 的 option</h4><ul><li>如下表所示 (其他的要去 manpage 查詢)</li></ul><table><thead><tr><th>options</th><th>details</th></tr></thead><tbody><tr><td><code>--host=arm-linux</code></td><td>運行平台</td></tr><tr><td><code>--target=arm-linux</code></td><td>目標平台</td></tr><tr><td><code>--build=i686-linux</code></td><td>編譯平台</td></tr><tr><td><code>--with-cc=arm-linux-gcc</code></td><td>cross-compiler tool</td></tr><tr><td><code>--with-ar=arm-linux-ar</code></td><td>打包工具</td></tr><tr><td><code>--prefix=/usr/local/net-snmp</code></td><td>安裝目錄</td></tr><tr><td><code>--disable-shared</code></td><td>不編譯共享庫</td></tr><tr><td><code>--disable-scripts</code></td><td>不要安裝 mib2c 等版本</td></tr><tr><td><code>--with-endianness=little</code></td><td>using little endian</td></tr><tr><td><code>--enable-mini-agent</code></td><td>最小化構建 agent</td></tr><tr><td><code>--disable-deprecated</code></td><td>不編譯放棄使用的功能</td></tr><tr><td><code>--without-logfile</code></td><td>指定 snmpd 不輸出 log 文件 (可以使用 <code>--with-logfile</code> 指定默認 log 檔案的位置)</td></tr><tr><td><code>--disable-minimalist</code></td><td>刪除所有非基本的代碼功能</td></tr><tr><td><code>--enable-debugging</code></td><td>打開除錯訊息</td></tr><tr><td><code>--disable-testing-code</code></td><td>不使用測試代碼 (某些代碼不被使用)</td></tr><tr><td><code>--with-openssl=/opt/hardhat</code></td><td>openssl library 路徑 (支援加密)</td></tr><tr><td><code>--disable-ipv6</code></td><td>不使用 ipv6</td></tr><tr><td><code>--disable-manuals</code></td><td>不安裝 manpage 說明頁</td></tr><tr><td><code>--disable-ucd-snmp-compatibility</code></td><td>不需要相容 ucd-snmp</td></tr><tr><td><code>--disable-snmptrapd-subagent</code></td><td>不需要支援 snmptrapd 的子代理</td></tr><tr><td><code>--disable-embedded-perl</code></td><td>在 snmp agent 和 snmptrapd 禁用 embedded perl 預設啟用</td></tr><tr><td><code>--disable-applications</code></td><td>是否關閉 snmpget 等功能，根據自己的需求選擇</td></tr><tr><td><code>--with-default-snmp-version=&quot;3&quot;</code></td><td>指定預設 snmp protocal version</td></tr><tr><td><code>--enable-as-needed</code></td><td>僅鏈接需要的library</td></tr></tbody></table><ul><li>根據以上，我組態設定為<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=<span class="regexp">/var/</span>net-snmp --build=i686-linux --host=arm-linux --<span class="keyword">with</span>-<span class="keyword">default</span>-snmp-version=<span class="string">"2"</span> --<span class="keyword">with</span>-sys-contact=<span class="string">"timmyliu@weintek.com"</span> --<span class="keyword">with</span>-sys-location=<span class="string">"location"</span> --<span class="keyword">with</span>-logfile=<span class="string">"/var/log/snmpd.log"</span> --<span class="keyword">with</span>-copy-persistent-files=<span class="string">"no"</span> --without-opaque-special-types --without-rpm --without-perl-modules --disable-manuals --disable-ipv6 --disable-ucd-snmp-compatibility --disable-embedded-perl --disable-snmptrapd-subagent --disable-scripts -enable-mfd-rewrites --enable-shared=no --enable-mini-agent --<span class="keyword">with</span>-cc=arm-none-linux-gnueabi-gcc --<span class="keyword">with</span>-ar=arm-none-linux-gnueabi-ar</span><br></pre></td></tr></table></figure></li></ul><p>看不清所有設定的話，可以寫成：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=<span class="regexp">/var/</span>net-snmp \</span><br><span class="line">--build=i686-linux --host=arm-linux \</span><br><span class="line">--<span class="keyword">with</span>-<span class="keyword">default</span>-snmp-version=<span class="string">"2"</span> --<span class="keyword">with</span>-sys-contact=<span class="string">"timmyliu@weintek.com"</span> \</span><br><span class="line">--<span class="keyword">with</span>-sys-location=<span class="string">"location"</span> --<span class="keyword">with</span>-logfile=<span class="string">"/var/log/snmpd.log"</span> \</span><br><span class="line">--<span class="keyword">with</span>-copy-persistent-files=<span class="string">"no"</span> --without-opaque-special-types \</span><br><span class="line">--without-rpm --without-perl-modules \</span><br><span class="line">--disable-manuals --disable-ipv6 --disable-ucd-snmp-compatibility \</span><br><span class="line">--disable-embedded-perl --disable-snmptrapd-subagent --disable-scripts \</span><br><span class="line">-enable-mfd-rewrites --enable-shared=no --enable-mini-agent \</span><br><span class="line">--<span class="keyword">with</span>-cc=arm-none-linux-gnueabi-gcc \</span><br><span class="line">--<span class="keyword">with</span>-ar=arm-none-linux-gnueabi-ar</span><br></pre></td></tr></table></figure></p><ul><li>configure summary<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">---------------------------------------------------------</span><br><span class="line">            Net-SNMP configuration summary:</span><br><span class="line">---------------------------------------------------------</span><br><span class="line"></span><br><span class="line">  SNMP Versions Supported:    <span class="number">1</span> <span class="number">2</span>c <span class="number">3</span></span><br><span class="line">  Building <span class="keyword">for</span>:               linux</span><br><span class="line">  Net-SNMP Version:           <span class="number">5.8</span></span><br><span class="line">  Network transport support:  Callback Unix Alias TCP UDP IPv4Base SocketBase TCPBase UDPIPv4Base UDPBase</span><br><span class="line">  SNMPv3 Security Modules:     usm</span><br><span class="line">  Agent MIB code:            <span class="function"><span class="params">default_modules</span> =&gt;</span>  snmpv3mibs mibII/snmp_mib mibII/system_mib mibII/sysORTable mibII/vacm_vars mibII/vacm_conf</span><br><span class="line">  MYSQL Trap Logging:         unavailable</span><br><span class="line">  Embedded Perl support:      disabled</span><br><span class="line">  SNMP Perl modules:          disabled</span><br><span class="line">  SNMP Python modules:        disabled</span><br><span class="line">  Crypto support <span class="keyword">from</span>:        internal</span><br><span class="line">  Authentication support:     MD5 SHA1</span><br><span class="line">  Encryption support:         DES AES</span><br><span class="line">  Local DNSSEC validation:    disabled</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------</span><br></pre></td></tr></table></figure></li></ul><h4 id="之後就執行-make"><a href="#之後就執行-make" class="headerlink" title="之後就執行 make"></a>之後就執行 <code>make</code></h4><ul><li>如果之前有 build 過的話就執行 <code>make clean &amp;&amp; make</code></li><li><p>build 成功的話會看到下面兩行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod a+x net-snmp-config</span><br><span class="line">touch net-snmp-config-x</span><br></pre></td></tr></table></figure></li><li><p>透過 <code>ll -h agent/snmpd</code> 看一下 size</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">weintek-timmy@weintek-timmy:~/Timmy/GitHub/net-snmp-5.8$ ll -h agent/snmpd</span><br><span class="line">-rwxrwxr-x 1 weintek-timmy weintek-timmy 2.3M 12月  4 15:58 agent/snmpd*</span><br></pre></td></tr></table></figure></li></ul><h4 id="使用strip進行程式瘦身"><a href="#使用strip進行程式瘦身" class="headerlink" title="使用strip進行程式瘦身"></a>使用strip進行程式瘦身</h4><p>看你是 soft-float 還是 hard-float compiler，以這個例子我們是使用 <code>arm-none-linux-gnueabi-</code>來編譯，那我們就使用 <code>arm-none-linux-gnueabi-strip</code>來瘦身<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">weintek-timmy<span class="meta">@weintek</span>-timmy:~<span class="regexp">/Timmy/</span>GitHub/net-snmp<span class="number">-5.8</span>$ arm-none-linux-gnueabi-strip agent/snmpd</span><br><span class="line">weintek-timmy<span class="meta">@weintek</span>-timmy:~<span class="regexp">/Timmy/</span>GitHub/net-snmp<span class="number">-5.8</span>$ ll -h agent/snmpd</span><br><span class="line">-rwxrwxr-x <span class="number">1</span> weintek-timmy weintek-timmy <span class="number">696</span>K <span class="number">12</span>月  <span class="number">4</span> <span class="number">16</span>:<span class="number">04</span> agent/snmpd*</span><br><span class="line">weintek-timmy<span class="meta">@weintek</span>-timmy:~<span class="regexp">/Timmy/</span>GitHub/net-snmp<span class="number">-5.8</span>$</span><br></pre></td></tr></table></figure></p><p>從 2.3M 瘦身成 696K</p><h3 id="3-學習-snmpd-conf-的設定"><a href="#3-學習-snmpd-conf-的設定" class="headerlink" title="3. 學習 snmpd.conf 的設定"></a>3. 學習 snmpd.conf 的設定</h3><p>具體配置方式可以參考<a href="http://www.cnblogs.com/oloroso/p/4595123.html" target="_blank" rel="noopener">這裡</a>的第五部份，然而我會從那個網站中將設定的方式紀錄於此</p><ul><li><p>複製 EXAMPLE.conf 到原本的資料夾中，用此製作一份新的 config file</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp EXAMPLE.conf snmpd.conf</span><br></pre></td></tr></table></figure></li><li><p>開啟外網 access 權限</p></li></ul><p>原本預設的 snmpd.conf 通常都是使用 localhost (127.0.0.1)，如果要使用外網訪問的話，就要修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#    AGENT BEHAVIOUR</span><br><span class="line">#</span><br><span class="line">#  Listen for connections from the local system only</span><br><span class="line">#  agentAddress  udp:127.0.0.1:161</span><br><span class="line">#  Listen for connections on all interfaces (both IPv4 *and* IPv6)</span><br><span class="line">agentAddress udp:161,udp6:[::1]:161</span><br></pre></td></tr></table></figure></p><p>如果把 <code>#agentAddress upd:127.0.0.1:161</code> 解開的話就會變成使用 localhost listen</p><ul><li>設定共同體名稱 (community)</li></ul><p>我們使用 EXAMPLE.conf 中的 com2sec/group/view/access 的說明，大約是預設文件的第 65 行</p><p>首先我們定義一個首<strong>共同體名稱</strong>(community)，這裡我們使用 public，以及可以訪問這個 public 的用戶名(sec name)，這裡是 notConfigUser。public 相當於用戶 notConfigUser 的密碼</p><p>在 snmpd.conf 檔案中加入以下 (可使用 “#” 來加入註解)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#        sec.name        source    community</span><br><span class="line">com2sec  notConfigUser   default   public</span><br></pre></td></tr></table></figure></p><ul><li>定義 gpoup 名稱 (組名)</li></ul><p>之後我們定義一個組名 (groupName) 這裡是 notConfigGroup，以及 group 的安全級別(也就是 snmp version) 並把 notConfigUser 這個用戶加到這個 group 中。</p><p>在 snmpd.conf 檔案中加入以下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#       groupName       securityModel    securityName</span><br><span class="line">group   notConfigGroup      v1           notConfigUser</span><br><span class="line">group   notConfigGroup      v2c          notConfigUser</span><br></pre></td></tr></table></figure></p><ul><li>定義可試圖 (view) 名稱</li></ul><p>我們加入 all 這個名稱，可視範圍為 .1，在 snmpd.conf 檔案中加入以下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#       name     incl/excl     subtree      mask(optional)</span><br><span class="line">view     all      included        .1</span><br></pre></td></tr></table></figure></p><p>並且註解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">view   systemonly  included   .1.3.6.1.2.1.1</span><br><span class="line">view   systemonly  included   .1.3.6.1.2.1.25.1</span><br></pre></td></tr></table></figure></p><ul><li>定義可試圖操作</li></ul><p>最後定義 notConfigUser 這個組在 all 這個可視圖中內可做的操作，我們在此定義了 notConfigGroup 內的成員可以對 .1 這個可視範圍做 <strong>「唯讀」</strong> 操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#          group        context sec.model  sec.level  prefix read   write  notif</span><br><span class="line">access  notConfigGroup    &quot;&quot;      any       noauth    exact  all    none   none</span><br></pre></td></tr></table></figure></p><p>接下來設置系統資訊</p><ul><li><p>設置區域</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysLocation    &quot;New Taipei City, Taiwan&quot;</span><br></pre></td></tr></table></figure></li><li><p>設置聯絡人</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysContact     Me &lt;me@example.org&gt;</span><br></pre></td></tr></table></figure></li><li><p>設置監控主機</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>設置讀寫帳戶<br><code></code>conf=</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">### 4. 移植到 arm-linux 進行測試</span><br><span class="line"></span><br><span class="line">* 先從 agent 目錄下 copy 出 snmpd 執行檔</span><br><span class="line">* 在 embedded-linux 目標機器上創建 snmpd.conf 的設定文件 (我習慣在PC上面先建置好再透過 `scp` 拷貝到裝置內)</span><br><span class="line">```sh=</span><br><span class="line">scp agent/snmpd snmp.conf root@192.168.2.98:/root/</span><br></pre></td></tr></table></figure></li><li><p><strong>之後執行 <code>./snmpd -c snmpd.conf  –f –Le –d</code></strong> (大部份都要除錯，很少第一次成功)</p></li></ul><h3 id="5-除錯與問題處理"><a href="#5-除錯與問題處理" class="headerlink" title="5. 除錯與問題處理"></a>5. 除錯與問題處理</h3><h4 id="遇到-cannot-file-module-與-snmpd-conf-unknown-token-的問題"><a href="#遇到-cannot-file-module-與-snmpd-conf-unknown-token-的問題" class="headerlink" title="遇到 cannot file module 與 snmpd.conf: unknown token 的問題"></a>遇到 cannot file module 與 snmpd.conf: unknown token 的問題</h4><p>執行時遇到問題<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@cMT-15C2 /root]<span class="comment"># ./snmpd -c snmpd.conf -f -Le -d</span></span><br><span class="line">Created directory: /var/net-snmp</span><br><span class="line">Created directory: /var/net-snmp/mib_indexes</span><br><span class="line">MIB search path: /root/.snmp/mibs:/var/net-snmp/share/snmp/mibs</span><br><span class="line">Cannot find module (SNMPv2-MIB): At line 0 <span class="keyword">in</span> (none)</span><br><span class="line">Cannot find module (IF-MIB): At line 0 <span class="keyword">in</span> (none)</span><br><span class="line">Cannot find module (IP-MIB): At line 0 <span class="keyword">in</span> (none)</span><br><span class="line">Cannot find module (TCP-MIB): At line 0 <span class="keyword">in</span> (none)</span><br><span class="line">Cannot find module (UDP-MIB): At line 0 <span class="keyword">in</span> (none)</span><br><span class="line">Cannot find module (SNMP-VIEW-BASED-ACM-MIB): At line 0 <span class="keyword">in</span> (none)</span><br><span class="line">Cannot find module (SNMP-COMMUNITY-MIB): At line 0 <span class="keyword">in</span> (none)</span><br><span class="line">Cannot find module (SNMP-FRAMEWORK-MIB): At line 0 <span class="keyword">in</span> (none)</span><br><span class="line">Cannot find module (SNMP-MPD-MIB): At line 0 <span class="keyword">in</span> (none)</span><br><span class="line">Cannot find module (SNMP-USER-BASED-SM-MIB): At line 0 <span class="keyword">in</span> (none)</span><br><span class="line">snmpd.conf: line 96: Warning: Unknown token: proc.</span><br><span class="line">snmpd.conf: line 98: Warning: Unknown token: proc.</span><br><span class="line">snmpd.conf: line 100: Warning: Unknown token: proc.</span><br><span class="line">snmpd.conf: line 110: Warning: Unknown token: disk.</span><br><span class="line">snmpd.conf: line 111: Warning: Unknown token: disk.</span><br><span class="line">snmpd.conf: line 112: Warning: Unknown token: includeAllDisks.</span><br><span class="line">snmpd.conf: line 122: Warning: Unknown token: load.</span><br><span class="line">snmpd.conf: line 149: Warning: Unknown token: iquerySecName.</span><br><span class="line">snmpd.conf: line 152: Warning: Unknown token: defaultMonitors.</span><br><span class="line">snmpd.conf: line 154: Warning: Unknown token: linkUpDownNotifications.</span><br><span class="line">snmpd.conf: line 166: Warning: Unknown token: extend.</span><br><span class="line">snmpd.conf: line 167: Warning: Unknown token: extend-sh.</span><br><span class="line">snmpd.conf: line 199: Warning: Unknown token: master.</span><br><span class="line">Error opening specified endpoint <span class="string">"udp:161"</span></span><br><span class="line">Server Exiting with code 1</span><br></pre></td></tr></table></figure></p><p>這個問題分兩部份</p><ul><li>Cannot find module…</li><li>snmpd.conf: line …: Warning: Unknown token: …</li></ul><h5 id="處理-snmpd-conf-line-Warning-Unknown-token-的問題"><a href="#處理-snmpd-conf-line-Warning-Unknown-token-的問題" class="headerlink" title="處理 snmpd.conf: line ...: Warning: Unknown token: ... 的問題"></a>處理 <code>snmpd.conf: line ...: Warning: Unknown token: ...</code> 的問題</h5><p>如果仔細去看他的 warning 的話，其實很簡單，他就是認不出這些設定檔，原因是因為這些設定可能因為執行 ./configure 的時候 disable 掉了，反正不設他就會使用預設的參數，所以我們就全部註解掉</p><ol><li>將 proc 的設定註解</li><li>將 disk / includeAllDisks 註解</li><li>將 load 註解</li><li>將 iquerySecName / defaultMonitors / linkUpDownNotifications 註解</li><li>將 extend / extend-sh / master 註解</li><li>將 trapsink 註解</li></ol><p>傳到裝置上再執行一次</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@cMT-15C2 /root]<span class="comment"># ./snmpd -c snmpd.conf -f -Le -d</span></span><br><span class="line">MIB search path: /root/.snmp/mibs:/var/net-snmp/share/snmp/mibs</span><br><span class="line">Cannot find module (SNMPv2-MIB): At line 0 <span class="keyword">in</span> (none)</span><br><span class="line">Cannot find module (IF-MIB): At line 0 <span class="keyword">in</span> (none)</span><br><span class="line">Cannot find module (IP-MIB): At line 0 <span class="keyword">in</span> (none)</span><br><span class="line">Cannot find module (TCP-MIB): At line 0 <span class="keyword">in</span> (none)</span><br><span class="line">Cannot find module (UDP-MIB): At line 0 <span class="keyword">in</span> (none)</span><br><span class="line">Cannot find module (SNMP-VIEW-BASED-ACM-MIB): At line 0 <span class="keyword">in</span> (none)</span><br><span class="line">Cannot find module (SNMP-COMMUNITY-MIB): At line 0 <span class="keyword">in</span> (none)</span><br><span class="line">Cannot find module (SNMP-FRAMEWORK-MIB): At line 0 <span class="keyword">in</span> (none)</span><br><span class="line">Cannot find module (SNMP-MPD-MIB): At line 0 <span class="keyword">in</span> (none)</span><br><span class="line">Cannot find module (SNMP-USER-BASED-SM-MIB): At line 0 <span class="keyword">in</span> (none)</span><br><span class="line">Error opening specified endpoint <span class="string">"udp:161"</span></span><br><span class="line">Server Exiting with code 1</span><br></pre></td></tr></table></figure><h5 id="處理-cannot-find-module-問題"><a href="#處理-cannot-find-module-問題" class="headerlink" title="處理 cannot find module 問題"></a>處理 cannot find module 問題</h5><p>問題點從 message 就大概可以知道 MIB module 需要匯入，而路徑是 <code>/var/net-snmp/share/snmp/mibs</code></p><p>所以我們就先建立新的資料夾<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /var/net-snmp/share/snmp/mibs</span><br></pre></td></tr></table></figure></p><p>然後進入 PC source code 的 mibs 將裏面的 module 撈出來給裝置<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~net-snmp-5.8/mibs</span><br><span class="line"></span><br><span class="line">scp * root@192.168.2.98:/var/net-snmp/share/snmp/mibs/</span><br></pre></td></tr></table></figure></p><p>再執行一次<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@cMT-15C2 /root]<span class="comment"># ./snmpd -c snmpd.conf -f -Le -d</span></span><br><span class="line">Error opening specified endpoint <span class="string">"udp:161"</span></span><br><span class="line">Server Exiting with code 1</span><br></pre></td></tr></table></figure></p><p>還有最後一個問題</p><h5 id="處理-Error-opening-specified-endpoint-“udp-161”"><a href="#處理-Error-opening-specified-endpoint-“udp-161”" class="headerlink" title="處理 Error opening specified endpoint “udp:161”"></a>處理 Error opening specified endpoint “udp:161”</h5><p>因為我們之前使用 <code>./configure</code> 的時候加入了一個參數 <code>--disable-ipv6</code> ，所以我們必須將 udp的 ipv6設定移掉<br>修改 <code>snmpd.conf</code> ，將 <code>udp6:[::1]:161</code> 移掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># orig: agentAddress udp:161,udp6:[::1]:161</span><br><span class="line">agentAddress udp:161</span><br></pre></td></tr></table></figure><p>還有其他可能性，但大部份都是 conf 檔要放對位置</p><h3 id="6-使用-snmp-client-來驗證正確"><a href="#6-使用-snmp-client-來驗證正確" class="headerlink" title="6. 使用 snmp client 來驗證正確"></a>6. 使用 snmp client 來驗證正確</h3><p>若使用指令 <code>./snmpd -c snmpd.conf -f -Le -d</code> 啟動之後出現 <code>NET-SNMP version 5.8</code> 表示已經運行，這時候我們使用 <code>snmpwalk</code> 試試看</p><ul><li><p>PC 端：</p><ul><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">snmpget -v 2c -c public 192.168.2.98 sysDescr.0</span><br><span class="line">SNMPv2-MIB::sysDescr.0 = STRING: Linux cMT-15C2 4.1.15+ #629 PREEMPT Fri Aug 10 18:14:50 CST 2018 armv7l</span><br></pre></td></tr></table></figure></li></ul></li><li><p>裝置端：</p><ul><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Received 43 byte packet from UDP: [192.168.1.21]:59770-&gt;[192.168.2.98]:161</span><br><span class="line">0000: 30 29 02 01  01 04 06 70  75 62 6C 69  63 A0 1C 02    0).....public...</span><br><span class="line">0016: 04 12 1B C8  08 02 01 00  02 01 00 30  0E 30 0C 06    ...........0.0..</span><br><span class="line">0032: 08 2B 06 01  02 01 01 01  00 05 00                    .+.........</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Sending 114 bytes to UDP: [192.168.1.21]:59770-&gt;[192.168.2.98]:161</span><br><span class="line">0000: 30 70 02 01  01 04 06 70  75 62 6C 69  63 A2 63 02    0p.....public.c.</span><br><span class="line">0016: 04 12 1B C8  08 02 01 00  02 01 00 30  55 30 53 06    ...........0U0S.</span><br><span class="line">0032: 08 2B 06 01  02 01 01 01  00 04 47 4C  69 6E 75 78    .+........GLinux</span><br><span class="line">0048: 20 63 4D 54  2D 31 35 43  32 20 34 2E  31 2E 31 35     cMT-15C2 4.1.15</span><br><span class="line">0064: 2B 20 23 36  32 39 20 50  52 45 45 4D  50 54 20 46    + #629 PREEMPT F</span><br><span class="line">0080: 72 69 20 41  75 67 20 31  30 20 31 38  3A 31 34 3A    ri Aug 10 18:14:</span><br><span class="line">0096: 35 30 20 43  53 54 20 32  30 31 38 20  61 72 6D 76    50 CST 2018 armv</span><br><span class="line">0112: 37 6C</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>我們可以再寫一個 snmpwalk 來抓取系統狀態<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">weintek-timmy<span class="meta">@weintek</span>-timmy:~$ snmpwalk -v <span class="number">1</span> <span class="number">192.168</span><span class="number">.2</span><span class="number">.98</span> -c <span class="keyword">public</span> system</span><br><span class="line">SNMPv2-MIB::sysDescr<span class="number">.0</span> = STRING: Linux cMT<span class="number">-15</span>C2 <span class="number">4.1</span><span class="number">.15</span>+ #<span class="number">629</span> PREEMPT Fri Aug <span class="number">10</span> <span class="number">18</span>:<span class="number">14</span>:<span class="number">50</span> CST <span class="number">2018</span> armv7l</span><br><span class="line">SNMPv2-MIB::sysObjectID<span class="number">.0</span> = OID: NET-SNMP-MIB::netSnmpAgentOIDs<span class="number">.10</span></span><br><span class="line">DISMAN-EVENT-MIB::sysUpTimeInstance = Timeticks: (<span class="number">55157</span>) <span class="number">0</span>:<span class="number">09</span>:<span class="number">11.57</span></span><br><span class="line">SNMPv2-MIB::sysContact<span class="number">.0</span> = STRING: Me &lt;me<span class="meta">@example</span>.org&gt;</span><br><span class="line">SNMPv2-MIB::sysName<span class="number">.0</span> = STRING: cMT<span class="number">-15</span>C2</span><br><span class="line">SNMPv2-MIB::sysLocation<span class="number">.0</span> = STRING: \<span class="string">"New Taipei City, Taiwan\"</span></span><br><span class="line"><span class="string">SNMPv2-MIB::sysServices.0 = INTEGER: 72</span></span><br><span class="line"><span class="string">SNMPv2-MIB::sysORLastChange.0 = Timeticks: (0) 0:00:00.00</span></span><br><span class="line"><span class="string">SNMPv2-MIB::sysORID.1 = OID: SNMPv2-MIB::snmpMIB</span></span><br><span class="line"><span class="string">SNMPv2-MIB::sysORID.2 = OID: SNMP-VIEW-BASED-ACM-MIB::vacmBasicGroup</span></span><br><span class="line"><span class="string">SNMPv2-MIB::sysORID.3 = OID: SNMP-FRAMEWORK-MIB::snmpFrameworkMIBCompliance</span></span><br><span class="line"><span class="string">SNMPv2-MIB::sysORID.4 = OID: SNMP-MPD-MIB::snmpMPDCompliance</span></span><br><span class="line"><span class="string">SNMPv2-MIB::sysORID.5 = OID: SNMP-USER-BASED-SM-MIB::usmMIBCompliance</span></span><br><span class="line"><span class="string">SNMPv2-MIB::sysORDescr.1 = STRING: The MIB module for SNMPv2 entities</span></span><br><span class="line"><span class="string">SNMPv2-MIB::sysORDescr.2 = STRING: View-based Access Control Model for SNMP.</span></span><br><span class="line"><span class="string">SNMPv2-MIB::sysORDescr.3 = STRING: The SNMP Management Architecture MIB.</span></span><br><span class="line"><span class="string">SNMPv2-MIB::sysORDescr.4 = STRING: The MIB for Message Processing and Dispatching.</span></span><br><span class="line"><span class="string">SNMPv2-MIB::sysORDescr.5 = STRING: The management information definitions for the SNMP User-based Security Model.</span></span><br><span class="line"><span class="string">SNMPv2-MIB::sysORUpTime.1 = Timeticks: (0) 0:00:00.00</span></span><br><span class="line"><span class="string">SNMPv2-MIB::sysORUpTime.2 = Timeticks: (0) 0:00:00.00</span></span><br><span class="line"><span class="string">SNMPv2-MIB::sysORUpTime.3 = Timeticks: (0) 0:00:00.00</span></span><br><span class="line"><span class="string">SNMPv2-MIB::sysORUpTime.4 = Timeticks: (0) 0:00:00.00</span></span><br><span class="line"><span class="string">SNMPv2-MIB::sysORUpTime.5 = Timeticks: (0) 0:00:00.00</span></span><br></pre></td></tr></table></figure></p><h2 id="SNMP-OID-使用"><a href="#SNMP-OID-使用" class="headerlink" title="SNMP OID 使用"></a>SNMP OID 使用</h2><p>我們使用 <code>snmpwalk</code> 來取得目前 mib 可以使用的 module<br>只要輸入 <code>snmpwalk -v 2c -c public 192.168.2.98</code> 就可以 printf 出可以獲得的訊息</p><h3 id="Linux-常用的-OID"><a href="#Linux-常用的-OID" class="headerlink" title="Linux 常用的 OID"></a>Linux 常用的 OID</h3><h4 id="Load"><a href="#Load" class="headerlink" title="Load"></a>Load</h4><table><thead><tr><th>function</th><th>OID</th></tr></thead><tbody><tr><td>1 minute Load</td><td><code>.1.3.6.1.4.1.2021.10.1.3.1</code></td></tr><tr><td>5 minute Load</td><td><code>.1.3.6.1.4.1.2021.10.1.3.2</code></td></tr><tr><td>15 minute Load</td><td><code>.1.3.6.1.4.1.2021.10.1.3.3</code></td></tr></tbody></table><h4 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h4><table><thead><tr><th>function</th><th>OID</th></tr></thead><tbody><tr><td>percentage of user CPU time</td><td><code>.1.3.6.1.4.1.2021.11.9.0</code></td></tr><tr><td>raw user cpu time</td><td><code>.1.3.6.1.4.1.2021.11.50.0</code></td></tr><tr><td>percentages of system CPU time</td><td><code>.1.3.6.1.4.1.2021.11.10.0</code></td></tr><tr><td>raw system cpu time</td><td><code>.1.3.6.1.4.1.2021.11.52.0</code></td></tr><tr><td>percentages of idle CPU time</td><td><code>.1.3.6.1.4.1.2021.11.11.0</code></td></tr><tr><td>raw idle cpu time</td><td><code>.1.3.6.1.4.1.2021.11.53.0</code></td></tr><tr><td>raw nice cpu time</td><td><code>.1.3.6.1.4.1.2021.11.51.0</code></td></tr></tbody></table><hr><h4 id="內部儲存資訊"><a href="#內部儲存資訊" class="headerlink" title="內部儲存資訊"></a>內部儲存資訊</h4><table><thead><tr><th>function</th><th>OID</th></tr></thead><tbody><tr><td>Total Swap Size</td><td><code>.1.3.6.1.4.1.2021.4.3.0</code></td></tr><tr><td>Available Swap Space</td><td><code>.1.3.6.1.4.1.2021.4.4.0</code></td></tr><tr><td>Total RAM in machine</td><td><code>.1.3.6.1.4.1.2021.4.5.0</code></td></tr><tr><td>Total RAM used</td><td><code>.1.3.6.1.4.1.2021.4.6.0</code></td></tr><tr><td>Total RAM Free</td><td><code>.1.3.6.1.4.1.2021.4.11.0</code></td></tr><tr><td>Total RAM Shared</td><td><code>.1.3.6.1.4.1.2021.4.13.0</code></td></tr><tr><td>Total RAM Buffered</td><td><code>.1.3.6.1.4.1.2021.4.14.0</code></td></tr><tr><td>Total Cached Memory</td><td><code>.1.3.6.1.4.1.2021.4.15.0</code></td></tr></tbody></table><hr><h4 id="Disk-相關"><a href="#Disk-相關" class="headerlink" title="Disk 相關"></a>Disk 相關</h4><blockquote><p>The snmpd.conf needs to be edited. Add the following (assuming a machine with a single ‘/’ partition):<br>disk / 100000 (or)<br>includeAllDisks 10% for all partitions and disks<br>The OIDs are as follows</p></blockquote><table><thead><tr><th>function</th><th>OID</th></tr></thead><tbody><tr><td>Path where the disk is mounted</td><td><code>.1.3.6.1.4.1.2021.9.1.2.1</code></td></tr><tr><td>Path of the device for the partition</td><td><code>.1.3.6.1.4.1.2021.9.1.3.1</code></td></tr><tr><td>Total size of the disk/partion (kBytes)</td><td><code>.1.3.6.1.4.1.2021.9.1.6.1</code></td></tr><tr><td>Available space on the disk</td><td><code>.1.3.6.1.4.1.2021.9.1.7.1</code></td></tr><tr><td>Used space on the disk</td><td><code>.1.3.6.1.4.1.2021.9.1.8.1</code></td></tr><tr><td>Percentage of space used on disk</td><td><code>.1.3.6.1.4.1.2021.9.1.9.1</code></td></tr><tr><td>Percentage of inodes used on disk</td><td><code>.1.3.6.1.4.1.2021.9.1.10.1</code></td></tr></tbody></table><hr><h4 id="系統運行時間"><a href="#系統運行時間" class="headerlink" title="系統運行時間"></a>系統運行時間</h4><table><thead><tr><th>function</th><th>OID</th></tr></thead><tbody><tr><td>System Uptime</td><td><code>.1.3.6.1.2.1.1.3.0</code></td></tr></tbody></table><p>PS: linux 系统也可直接用 uptime 命令獲得系統資訊</p><h4 id="網路設備相關"><a href="#網路設備相關" class="headerlink" title="網路設備相關"></a>網路設備相關</h4><table><thead><tr><th>function</th><th>OID</th><th>功能說明</th></tr></thead><tbody><tr><td>ifIndex</td><td><code>1.3.6.1.2.1.2.2.1.1.0</code></td><td>端口索引編號</td></tr><tr><td>ifDescr</td><td><code>1.3.6.1.2.1.2.2.1.2.0</code></td><td>端口描述</td></tr><tr><td>ifType</td><td><code>1.3.6.1.2.1.2.2.1.3.0</code></td><td>端口類型</td></tr><tr><td>ifMtu</td><td><code>1.3.6.1.2.1.2.2.1.4.0</code></td><td>最大傳輸封包字節數</td></tr><tr><td>ifSpeed</td><td><code>1.3.6.1.2.1.2.2.1.5.0</code></td><td>端口速度</td></tr><tr><td>ifPhysAddress</td><td><code>1.3.6.1.2.1.2.2.1.6.0</code></td><td>MAC address</td></tr><tr><td>ifOperStatus</td><td><code>1.3.6.1.2.1.2.2.1.8.0</code></td><td>操作狀態</td></tr><tr><td>ifLastChange</td><td><code>1.3.6.1.2.1.2.2.1.9.0</code></td><td>上次狀態更新時間</td></tr><tr><td>ifInOctets</td><td><code>1.3.6.1.2.1.2.2.1.10.0</code></td><td>輸入字節數</td></tr><tr><td>ifInUcastPkts</td><td><code>1.3.6.1.2.1.2.2.1.11.0</code></td><td>輸入非廣播封包數</td></tr><tr><td>ifInNUcastPkts</td><td><code>1.3.6.1.2.1.2.2.1.12.0</code></td><td>輸入廣播封包數</td></tr><tr><td>ifInDiscards</td><td><code>1.3.6.1.2.1.2.2.1.13.0</code></td><td>輸入封包丟棄數</td></tr><tr><td>ifInErrors</td><td><code>1.3.6.1.2.1.2.2.1.14.0</code></td><td>輸入封包錯誤數</td></tr><tr><td>ifInUnknownProtos</td><td><code>1.3.6.1.2.1.2.2.1.15.0</code></td><td>輸入未知協議封包數</td></tr><tr><td>ifOutOctets</td><td><code>1.3.6.1.2.1.2.2.1.16.0</code></td><td>輸出字節數</td></tr><tr><td>ifOutUcastPkts</td><td><code>1.3.6.1.2.1.2.2.1.17.0</code></td><td>輸出非廣播封包數</td></tr><tr><td>ifOutNUcastPkts</td><td><code>1.3.6.1.2.1.2.2.1.18.0</code></td><td>輸出廣播封包數</td></tr><tr><td>ifOutDiscards</td><td><code>1.3.6.1.2.1.2.2.1.19.0</code></td><td>輸出封包丟棄數</td></tr><tr><td>ifOutErrors</td><td><code>1.3.6.1.2.1.2.2.1.20.0</code></td><td>輸出封包錯誤數</td></tr><tr><td>ifOutQLen</td><td><code>1.3.6.1.2.1.2.2.1.21.0</code></td><td>output queue size</td></tr></tbody></table><p>流量輸出是用計數器，數目會改變，單位是 byte, 32 位<br>如果流量大過出現土寄不正確的情形，就需要在編譯時加上 <code>enable-mfd-rewrites</code> 參數，來支援 64 位的計數器</p><h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><ul><li><a href="https://www.cnblogs.com/quliuliu2013/p/7520241.html" target="_blank" rel="noopener">https://www.cnblogs.com/quliuliu2013/p/7520241.html</a></li><li><a href="http://www.cnblogs.com/oloroso/p/4595123.html" target="_blank" rel="noopener">http://www.cnblogs.com/oloroso/p/4595123.html</a></li><li><a href="http://jyhshin.pixnet.net/blog/post/44844463-net-snmp-porting" target="_blank" rel="noopener">http://jyhshin.pixnet.net/blog/post/44844463-net-snmp-porting</a></li><li><a href="https://blog.csdn.net/gujintong1110/article/details/51791097" target="_blank" rel="noopener">https://blog.csdn.net/gujintong1110/article/details/51791097</a></li><li><a href="https://my.oschina.net/yisenn/blog/14679" target="_blank" rel="noopener">https://my.oschina.net/yisenn/blog/14679</a></li><li><a href="https://my.oschina.net/yisenn/blog/14626" target="_blank" rel="noopener">https://my.oschina.net/yisenn/blog/14626</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;目前我的想法是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先找 snmp packages 並嘗試透過 cross-compiler build snmp packages&lt;/li&gt;
&lt;li&gt;使用 pc build 一版 x86 版本的 snmpd&lt;/li&gt;
&lt;li&gt;學習 PC 如何透過 snmp client 來驗證 snmpd&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文目前只有詳細介紹第1點&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://m033010041.github.io/tags/Linux/"/>
    
      <category term="SNMP" scheme="https://m033010041.github.io/tags/SNMP/"/>
    
      <category term="Embedded linux" scheme="https://m033010041.github.io/tags/Embedded-linux/"/>
    
      <category term="i.MX6" scheme="https://m033010041.github.io/tags/i-MX6/"/>
    
  </entry>
  
  <entry>
    <title>[讀書心得] The Linux Programming Interface 第 19 章：檔案監控事件</title>
    <link href="https://m033010041.github.io/2018/11/21/TLPI-inotify/"/>
    <id>https://m033010041.github.io/2018/11/21/TLPI-inotify/</id>
    <published>2018-11-21T01:59:28.127Z</published>
    <updated>2018-11-21T16:42:57.694Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inotify_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>wd;</span><br><span class="line">    <span class="keyword">uint32_t</span>mask;</span><br><span class="line">    <span class="keyword">uint32_t</span>cookie;</span><br><span class="line">    <span class="keyword">uint32_t</span>len;</span><br><span class="line">    <span class="keyword">char</span>name[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這一章節，主要是在了解應用程式為了知道監控物件 (object) 發生了哪些事件，需要能夠監視檔案以及目錄，像是說</p><ul><li>圖形化的檔案管理程式可以知道檔案何時從目前的正在顯示的目錄中新增或是刪除</li><li>一個守護程式 (又稱常駐程式, daemon) 可能會監視一個組態檔案觀察是否該檔案是否有被更動過</li></ul><p>從 kernel <code>v2.6.13</code> 開始，Linux 提供了 inotify 機制，接受應用程式監控檔案與目錄事件<br>inotify 機制取代了舊有的 dnotify 機制，最後會介紹 dnotify 並且解釋 inotify 為何比較好</p><h2 id="19-1-概觀"><a href="#19-1-概觀" class="headerlink" title="19.1 概觀"></a>19.1 概觀</h2><p>使用 inotify API 步驟</p><ol><li>先使用 <code>inotify_init()</code> 建立一個 inotify instance，之後會回傳一個檔案描述符 (file descriptor)</li><li>針對核心有興趣的檔案，使用 <code>inotify_add_watch()</code> 新增項目到所建立的 inotify instance 中，每個項目都有一個路徑名稱與監控事件集合，透過函式內的位元遮罩 (bit mask) 進行處理</li><li><code>inotify_add_watch()</code> 針對每一個監控項目，回傳一個監控描述符 (watch descriptor, wd)</li><li>透過 <code>read()</code> 操作讀取 inotify instance，每次成功 <code>read()</code> 後都會回傳一個以上的 <code>inotify_event</code> 結構</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inotify_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>wd;</span><br><span class="line">    <span class="keyword">uint32_t</span>mask;</span><br><span class="line">    <span class="keyword">uint32_t</span>cookie;</span><br><span class="line">    <span class="keyword">uint32_t</span>len;</span><br><span class="line">    <span class="keyword">char</span>name[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="19-2-inotify-API"><a href="#19-2-inotify-API" class="headerlink" title="19.2 inotify API"></a>19.2 inotify API</h2><h3 id="新增-inotify-instance"><a href="#新增-inotify-instance" class="headerlink" title="新增 inotify instance"></a>新增 inotify instance</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/inotify.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns file descriptor on success, or -1 on error */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inotify_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>回傳的 file descriptor 可以對於一個 inotify instance 進行操作</p><h3 id="新增監看項目，回傳監看描述符"><a href="#新增監看項目，回傳監看描述符" class="headerlink" title="新增監看項目，回傳監看描述符"></a>新增監看項目，回傳監看描述符</h3><p>根據上方的步驟，接下來我們會執行<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/inotify.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns watch descriptor (wd) on success, or -1 on error */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inotify_add_watch</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uint32_t</span> mask)</span></span>;</span><br></pre></td></tr></table></figure></p><p>此項目會對 fd 所參考的 inotify instance 新增一個監看項目，每一個監看項目有</p><ul><li>監看路徑</li><li>監看事件集合 (bit mask)<br><img src="/2018/11/21/TLPI-inotify/19_1.png" width="70%"></li><li><strong>若 pathname 為空</strong>，則 <code>inotify_add_watch()</code> 會建立一個新的監看項目並回傳一個非負值的 watch descriptor</li></ul><h3 id="移除監看項目"><a href="#移除監看項目" class="headerlink" title="移除監看項目"></a>移除監看項目</h3><p>若要移除 inotify instance 中的監看項目，會使用系統呼叫：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/inotify.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns 0 on success, or -1 on error */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inotify_rm_watch</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> wd)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="19-3-inotify-Events"><a href="#19-3-inotify-Events" class="headerlink" title="19.3 inotify Events"></a>19.3 inotify Events</h2><p>下圖為 inotify 事件列表，可以透過 <code>inotify_add_watch()</code> 中的 mask 參數識別要監視的 pathname 事件集合</p><ul><li>當權限、所有者、連結計數、擴充屬性、使用者 ID 或是群組 ID 等 metadata 資料改變時，會發生 <code>IN_ATTRIB</code> 事件</li><li>若目標監視刪除時，會發生 <code>IN_DELETE_SELF</code> 事件，若受監視是 <strong>目錄</strong> 且目錄中的其中一個檔案被刪除時，會發生 <code>IN_DELETE</code> 事件</li><li>若受監視的物件重新命名時，會發生 <code>IN_MOVE_SELF</code> 事件，若 <strong>監視目錄</strong> 中的其中一個物件重新命名時，會發生 <code>IN_MOVE_FROM</code> 與 <code>IN_MOVE_TO</code> 事件</li></ul><h2 id="19-4-Read-inotify-Event"><a href="#19-4-Read-inotify-Event" class="headerlink" title="19.4 Read inotify Event"></a>19.4 Read inotify Event</h2><p>使用 <code>read()</code> 進行讀取事件動作<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Max_Event10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_LEN(Max_Event * ((sizeof(struct inotify_event) + NAME_MAX + 1)))</span></span><br><span class="line"><span class="keyword">int</span> numRead;</span><br><span class="line"><span class="keyword">int</span> inotifyFd; <span class="comment">//From inotify_init()</span></span><br><span class="line"><span class="keyword">char</span> buf[BUF_LEN];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* In function */</span></span><br><span class="line">numRead = read(inotifyFd, buf, BUF_LEN);</span><br></pre></td></tr></table></figure></p><p>讀取一次的量為各事件發生時的數目<br>事件發生數目為 <code>numRead / (BUF_LEN/Max_Event)</code></p><p><img src="/2018/11/21/TLPI-inotify/19_2.png" width="70%"><br><code>inotify_add_watch()</code> 的 mask 可以帶入 <code>sys/inotify.h</code> 中的 <code>IN_ALL_EVENT</code> ，定義如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN_ALL_EVENTS(IN_ACCESS | IN_MODIFY | IN_ATTRIB | IN_CLOSE_WRITE | \</span></span><br><span class="line"> IN_CLOSE_NOWRITE | IN_OPEN | IN_MOVED_FROM | \</span><br><span class="line"> IN_MOVED_TO | IN_DELETE | IN_CREATE | IN_DELETE_SELF)</span><br></pre></td></tr></table></figure><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><ol><li>add file / directory</li><li>modify file</li><li>using <code>echo hello &gt; file.txt</code></li><li>rename file</li><li>move file to other place</li><li><code>IN_ONESHOT</code> 使用觀察 <code>IN_IGNORED</code> 的狀況</li><li>若監視檔案移動到別的地方了，wd 中的 pathname 會不會更動？</li></ol><h2 id="19-5-佇列限制與-proc-檔案"><a href="#19-5-佇列限制與-proc-檔案" class="headerlink" title="19.5 佇列限制與 /proc 檔案"></a>19.5 佇列限制與 /proc 檔案</h2><p>在 linux kernel configuration 中要啟用 inotify，必須先開啟 menuconfig</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Symbol: INOTIFY_USER [=y]</span><br><span class="line">Type  : boolean Prompt:</span><br><span class="line">Inotify support for userspace</span><br><span class="line">  Defined at fs/notify/inotify/Kconfig:1</span><br><span class="line">  Location:</span><br><span class="line">    -&gt; File systems</span><br><span class="line">  Selects: ANON_INODES [=y] &amp;&amp; FSNOTIFY [=y]</span><br></pre></td></tr></table></figure><p>之後可以在 <code>/proc/sys/fs/inotify/</code> 中設定 inotify 機制的操作組態，此設定要為高權限使用者<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls -l /proc/sys/fs/inotify/</span><br><span class="line"></span><br><span class="line">-rw-r--r--1root0 Nov 21 14:58 max_queued_events</span><br><span class="line">-rw-r--r--1root0 Nov 21 14:58 max_user_instances</span><br><span class="line">-rw-r--r--1root0 Nov 21 14:58 max_user_watches</span><br></pre></td></tr></table></figure></p><ul><li><code>max_queued_events</code>: <font color="#FF0000">default 16384</font><ul><li>當呼叫 <code>inotify_init()</code> 時，這個值是設定新的 inotify instance 數目上限，若超過的話會產生 <code>IN_Q_OVERFLOW</code> 事件，wd return -1</li></ul></li><li><code>max_user_instances</code>: <font color="#FF0000">default 128</font><ul><li>真實使用者可以建立的 inotify instance 數目</li></ul></li><li><code>max_user_watches</code>: <font color="#FF0000">default 8192</font><ul><li>真實使用者可以建立的監看項目數量限制</li></ul></li><li>以上都可以進行設定</li></ul><h2 id="19-6-舊版本的系統監視檔案事件：dnotify"><a href="#19-6-舊版本的系統監視檔案事件：dnotify" class="headerlink" title="19.6 舊版本的系統監視檔案事件：dnotify"></a>19.6 舊版本的系統監視檔案事件：dnotify</h2><p>從 Linux kernel <code>v2.4</code> 之後支援，之後被 inotify 所取代，因為有許多限制：</p><ul><li>dnotify 是透過 signal 傳送事件通知，而 inotify 沒有使用訊號</li><li>dnotify 監視的單位是一個 <strong>目錄</strong> ，而 inotify 則可以用來監視檔案或目錄</li><li>為了監視目錄，dnotify 需要應用程式開啟那個目錄的 fd ，使用 file descriptor 會有兩個問題<ul><li>由於忙碌，所以包含那個目錄的檔案系統都不可以被卸載</li><li>每個目錄都需要 fd ，所以會消耗大量的檔案描述符，但 inotify 沒有使用，所以可以避免這個問題</li></ul></li><li>dnotify 事件資訊沒有 inotify 來得精準</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;inotify_event&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;		wd;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt;	mask;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt;	cookie;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt;	len;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;	name[];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="The Linux Programming Interface" scheme="https://m033010041.github.io/tags/The-Linux-Programming-Interface/"/>
    
      <category term="Linux" scheme="https://m033010041.github.io/tags/Linux/"/>
    
      <category term="讀書心得" scheme="https://m033010041.github.io/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>[讀書心得] The Linux Programming Interface 第 11 章：系統限制</title>
    <link href="https://m033010041.github.io/2018/10/03/TLPI-SysLimit/"/>
    <id>https://m033010041.github.io/2018/10/03/TLPI-SysLimit/</id>
    <published>2018-10-03T01:44:14.000Z</published>
    <updated>2018-11-21T16:42:04.111Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ getconf NAME_MAX ~/Desktop</span><br><span class="line">255</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>每個 Unix 系統對各種系統功能與資源受限，並提供(或是選擇不提供)由各種標準定義的選項，例如：</p><ul><li>一個行程能同時開啟多少個檔案？</li><li>系統是否支援即時訊號？</li><li>型別為 <code>int</code> 的變數可儲存的最大值是多少？</li><li>一個程式能有多大的參數清單？</li><li>路徑名稱的最大長度是多少？</li></ul><p>我們通常會制定一個應用程式的限制與選項(limits or options)， <strong>但會減少可攜性</strong> ，因為限制與選項會與 <strong>系統不同而隨之改變</strong> ，像是說：</p><ul><li>跨 unix 系統：隨著不同的 unix 系統會造成 <code>int</code> 可儲存的最大值不同。</li><li>在特地系統的執行期環境：應用程式可能是在 A 系統編譯，按對於 B 系統中有著不同的限制情形。</li><li>file system 的轉移：<ul><li>SystemV：檔名長度最多 14 位元組</li><li>BSD file system：檔名程度最多 255 位元組</li></ul></li></ul><h2 id="11-1-系統限制"><a href="#11-1-系統限制" class="headerlink" title="11.1 系統限制"></a>11.1 系統限制</h2><p>SUSv3 要求全部的系統，對於 SUSv3 指定的限制都要<strong>提供一個最小值</strong>，這樣就可以移植到遵循此標準的系統，通常會在 <code>&lt;limit.h&gt;</code> 常數中定義，命名原則使用前綴 <code>_POSIX_</code> 字串，而且<strong>通常</strong>包含 <code>_MAX</code> 字串，所以命名格式通常為 <code>_POSIX_XXX_MAX</code></p><blockquote><p>這邊其實很弔詭，其實命名 <strong>_MAX</strong> 但稱其名稱為最小值是一件很怪的事<br>當我們了解這個常數是用來定義某些資源或特性上限值的常數，此上限值必須有明確的最小值時，就可以清楚理解了。</p></blockquote><p>By the way: 在編譯的過程中遇到了一個問題，macos high sierra 升級到 macos mojave 之後執行 gcc -o … 會跳出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun</span><br></pre></td></tr></table></figure><p>此時的處理方式是透過 <a href="https://apple.stackexchange.com/questions/254380/macos-mojave-invalid-active-developer-path" target="_blank" rel="noopener">這個處理方式</a> 來解決，執行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure></p><p>在 mac 系統中</p><ul><li><code>limits.h</code> 放置於 <code>/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/limits.h</code></li><li><code>unistd.h</code> 放置於 <code>/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/unistd.h</code></li></ul><p>SUSv3 將其規範限制分成三類</p><ol><li>執行期恆定值(runtime invariant value)</li><li>路徑名稱變動值(pathname variable value)</li><li>執行期可增值(runtime increasable value)</li></ol><h3 id="執行期恆定值-runtime-invariant-value"><a href="#執行期恆定值-runtime-invariant-value" class="headerlink" title="執行期恆定值(runtime invariant value)"></a>執行期恆定值(runtime invariant value)</h3><h3 id="路徑名稱變動值-pathname-variable-value"><a href="#路徑名稱變動值-pathname-variable-value" class="headerlink" title="路徑名稱變動值(pathname variable value)"></a>路徑名稱變動值(pathname variable value)</h3><h3 id="執行期可增值-runtime-increasable-value"><a href="#執行期可增值-runtime-increasable-value" class="headerlink" title="執行期可增值(runtime increasable value)"></a>執行期可增值(runtime increasable value)</h3><ul><li>參數命名：於執行期時可用於 <code>sysconf()</code> 或是 <code>pathconf()</code> 以取得系統的限制值<ul><li><code>_SC_</code> 開頭的常數可用於 <code>sysconf()</code></li><li><code>_PC_</code> 開頭的常數可用於 <code>pathconf()</code> 或是 <code>fpathconf()</code></li></ul></li></ul><h3 id="從-shell-取得限制與選項：getconf"><a href="#從-shell-取得限制與選項：getconf" class="headerlink" title="從 shell 取得限制與選項：getconf"></a>從 shell 取得限制與選項：<code>getconf</code></h3><p>執行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ getconf variable-name [pathname]</span><br></pre></td></tr></table></figure></p><h2 id="11-2-在執行期取得系統限制與選項-sysconf"><a href="#11-2-在執行期取得系統限制與選項-sysconf" class="headerlink" title="11.2 在執行期取得系統限制與選項 sysconf()"></a>11.2 在執行期取得系統限制與選項 <code>sysconf()</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns value of limit specified by name,</span></span><br><span class="line"><span class="comment"> * or -1 if limit is indeterminate or an error occurred</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sysconf</span><span class="params">(<span class="keyword">int</span> name)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>參數 <code>name</code> 是定義於 <code>&lt;unistd.h&gt;</code> 的其中一個 <code>_SC_*</code> 常數</li><li>回傳內容即為限制值</li><li>若錯誤發生活是無法確定限制時則會回傳 -1，且 <strong>errno 非 0</strong> ，表示發生錯誤</li></ul><p>在 SUSv3 的規範之中，<em>sysconf()</em> 所傳回的限制值在呼叫的行程之生命週期內<strong>必須是個常數</strong></p><h2 id="11-3-在執行期取得檔案限制與選項-pathconf-fpathconf"><a href="#11-3-在執行期取得檔案限制與選項-pathconf-fpathconf" class="headerlink" title="11.3 在執行期取得檔案限制與選項 pathconf() / fpathconf()"></a>11.3 在執行期取得檔案限制與選項 <code>pathconf() / fpathconf()</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Both return value of limit specified by name,</span></span><br><span class="line"><span class="comment"> * or -1 if limit is indterminate or an error occurred</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">pathconf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fpathconf</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> name)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>pathconf()</code> 與 <code>fpathconf()</code> 不同之處就在於<ul><li><code>pathconf()</code> 輸入參數為路徑字串</li><li><code>fpathconf()</code> 是使用 file descriptor</li></ul></li><li>參數 <code>name</code> 是定義於 <code>&lt;unistd.h&gt;</code> 的其中一個 <code>_PC_*</code> 系列常數</li><li>與 <code>sysconf()</code> 相同地，回傳的結果我即為限制值，且可區分回傳的是限制值還是錯誤，也可以用 errno 分辨錯誤</li><li>與 <code>sysconf()</code> 不同的是：SUSv3 並不要求 <em>pathconf() / fpathconf()</em> 的回傳值必須在形成的生命週期內保持不變。例如，行程執行時， <strong>檔案系統可能會被卸載並以不同的性質重新裝載</strong></li></ul><h2 id="延伸：autoconf-automake-aclocal"><a href="#延伸：autoconf-automake-aclocal" class="headerlink" title="延伸：autoconf + automake + aclocal"></a>延伸：autoconf + automake + aclocal</h2><p>GNU Autoconf 是一個擴充工具，可以<strong>確定各種系統特性及限制的存在及設定</strong>，autoconf 可以基於所收集到的資訊而產生標頭檔，並將這些檔案 include 進 C 程式中。</p><h3 id="透過-autoconf-automake-aclocal-自動產生-Makefile"><a href="#透過-autoconf-automake-aclocal-自動產生-Makefile" class="headerlink" title="透過 autoconf + automake + aclocal 自動產生 Makefile"></a>透過 autoconf + automake + aclocal 自動產生 Makefile</h3><ul><li>首先要先安裝相關套件<br><code>brew install autoconf automake libtool</code></li><li><p>安裝完後就找一個 .c 檔試試看</p><ol><li>執行 <code>autoscan</code></li><li>會產生 <code>configure.scan</code></li><li><p>修改 <code>configure.scan</code> 後將其檔名修改成 <code>configure.in</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Process this file with autoconf to produce a con figure script.</span></span><br><span class="line"></span><br><span class="line">AC_INIT(src.c)</span><br><span class="line">AM_INIT_AUTOMAKE(src, 1.0)</span><br><span class="line"><span class="comment"># Checks for programs.</span></span><br><span class="line">AC_PROG_CC</span><br><span class="line"><span class="comment"># Checks for libraries.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Checks for header files.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Checks for typedefs, structures, and compiler ch aracteristics.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Checks for library functions.</span></span><br><span class="line"></span><br><span class="line">AC_OUTPUT(Makefile)</span><br></pre></td></tr></table></figure></li><li><p>執行 <code>aclocal</code></p></li><li>執行 <code>autoconf</code></li><li>應該會產生 <code>aclocal.m4 configure configure.in src.c</code></li><li><p>編輯 <code>Makefile.am</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AUTOMAKE_OPTIONS= foreign</span><br><span class="line"></span><br><span class="line">bin_PROGRAMS= src</span><br><span class="line"></span><br><span class="line">hello_SOURCES= src.c</span><br></pre></td></tr></table></figure></li><li><p>執行 <code>automake --add-missing</code></p></li><li>執行 <code>./configure</code></li><li>應該會產生 Makefile 等檔案</li><li>執行 <code>make / make install / make dist</code> 等即可</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ getconf NAME_MAX ~/Desktop&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;255&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="The Linux Programming Interface" scheme="https://m033010041.github.io/tags/The-Linux-Programming-Interface/"/>
    
      <category term="Linux" scheme="https://m033010041.github.io/tags/Linux/"/>
    
      <category term="讀書心得" scheme="https://m033010041.github.io/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>整理 (KSZ8863RLL &amp; KSZ8081) 軔體設置</title>
    <link href="https://m033010041.github.io/2018/06/20/imx6-porting-ksz8863rll/"/>
    <id>https://m033010041.github.io/2018/06/20/imx6-porting-ksz8863rll/</id>
    <published>2018-06-20T03:47:07.000Z</published>
    <updated>2020-01-14T08:44:28.057Z</updated>
    
    <content type="html"><![CDATA[<p>本文章針對 ksz8863rll 以及 ksz8081 在 i.MX6ULL 平台上進行 linux driver porting<br>閱讀全文以看更詳細的說明以及終於遇到的問題與心得</p><a id="more"></a><p>我在公司的工作內容中，需要 porting 兩個 phy ic<br>分別是</p><ul><li><a href="#設定-ksz8081">ksz8081 (之前幾種常用的 phy IC)</a><ul><li><a href="#Set-ksz8081-led-mode-to-active-mode">Set ksz8081 led mode to active mode</a></li></ul></li><li><a href="#設定-ksz8863rll">ksz8863rll (switch ic)</a><ul><li><a href="#MDIO-相關討論">MDIO 相關討論</a></li><li><a href="#mdio-address">mdio address</a></li><li><a href="#使用-phytest-來設定數值或取得-id">使用 phytest 來設定數值或取得 id</a></li><li><a href="#加入-fixed-link-來啟動-auto-linked-up">加入 fixed-link 來啟動 auto linked-up</a></li><li><a href="#ENET_REF_TX_CLK-的設置與確認-RX_ER-的設置">ENET_REF_TX_CLK 的設置與確認 RX_ER 的設置</a></li><li><a href="#針對-KSZ8863RLL-vendor-FAE-的-PHY-mode-以及-MAC-mode-進行解釋">針對 KSZ8863RLL vendor FAE 的 PHY mode 以及 MAC mode 進行解釋</a></li><li><a href="#Ping-大封包會-ping-不出去">Ping 大封包會 ping 不出去</a></li><li><a href="#硬體修改如下">硬體修改如下</a></li><li><a href="#軔體修改如下">軔體修改如下</a></li></ul></li><li><a href="#Reference">Reference</a></li></ul><hr><h2 id="設定-ksz8081-之前的機種常用"><a href="#設定-ksz8081-之前的機種常用" class="headerlink" title="設定 ksz8081 (之前的機種常用)"></a>設定 ksz8081 (之前的機種常用)</h2><p>設定大致上不需要更動，只需要更動 LED mode 就可以了</p><h3 id="Set-ksz8081-led-mode-to-active-mode"><a href="#Set-ksz8081-led-mode-to-active-mode" class="headerlink" title="Set ksz8081 led mode to active mode"></a>Set ksz8081 led mode to active mode</h3><p>Datasheet 這邊有解釋 reg address 0x1f / bit[5..4] 需要設成 [00]<br><img src="https://i.imgur.com/vNbWtIi.png" alt=""></p><p>之後在 drivers/net/phy/micrel.c 中找到設定 led mode 的 code<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kszphy_probe</span><span class="params">(struct phy_device *phydev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* ...... */</span></span><br><span class="line"><span class="comment">/* ...... */</span></span><br><span class="line">    <span class="keyword">if</span> (type-&gt;led_mode_reg) &#123;</span><br><span class="line">        ret = of_property_read_u32(np, <span class="string">"micrel,led-mode"</span>, &amp;priv-&gt;led_mode);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">            priv-&gt;led_mode = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (priv-&gt;led_mode &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            dev_err(&amp;phydev-&gt;dev, <span class="string">"invalid led mode: 0x%02x\n"</span>, priv-&gt;led_mode);</span><br><span class="line">            priv-&gt;led_mode = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        priv-&gt;led_mode = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* ...... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>表示 device tree 會抓取 <strong>“micrel,led-mode” 這個字串</strong><br>之後我們可以在 Documentation/devicetree/bindings/net/micrel.txt 中看到設定的方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Optional properties:</span><br><span class="line"></span><br><span class="line"> - micrel,led-mode : LED mode value to set for PHYs with configurable LEDs.</span><br><span class="line"></span><br><span class="line">        Configure the LED mode with single value. The list of PHYs and the</span><br><span class="line">        bits that are currently supported:</span><br><span class="line"></span><br><span class="line">        KSZ8001: register 0x1e, bits 15..14</span><br><span class="line">        KSZ8041: register 0x1e, bits 15..14</span><br><span class="line">        KSZ8021: register 0x1f, bits 5..4</span><br><span class="line">        KSZ8031: register 0x1f, bits 5..4</span><br><span class="line">        KSZ8051: register 0x1f, bits 5..4</span><br><span class="line">        KSZ8081: register 0x1f, bits 5..4</span><br><span class="line">        KSZ8091: register 0x1f, bits 5..4</span><br><span class="line"></span><br><span class="line">        See the respective PHY datasheet for the mode values.</span><br></pre></td></tr></table></figure></p><p>然後透過 grep -r “micrel,led-mode” 找到一些例子可將值寫進 0x1f 暫存器<br>但最後因為 arch/arm/mach-imx/mach-imx6ul.c 會重新定義此 reg 的值，因此直接修改此部份即可<br><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/arch/arm/mach-imx/mach-imx6ul.c b/arch/arm/mach-imx/mach-imx6ul.c</span><br><span class="line">index a01cf09..833b926 100644</span><br><span class="line"><span class="comment">--- a/arch/arm/mach-imx/mach-imx6ul.c</span></span><br><span class="line"><span class="comment">+++ b/arch/arm/mach-imx/mach-imx6ul.c</span></span><br><span class="line">@@ -270,35 +270,18 @@ static int ksz8081_phy_fixup(struct phy_device *dev)</span><br><span class="line">                phy_write(dev, 0x1f, 0x8110);</span><br><span class="line">                phy_write(dev, 0x16, 0x201);</span><br><span class="line">        &#125; else if (dev &amp;&amp; dev-&gt;interface == PHY_INTERFACE_MODE_RMII) &#123;</span><br><span class="line"><span class="deletion">-               phy_write(dev, 0x1f, 0x8190);</span></span><br><span class="line"><span class="addition">+               phy_write(dev, 0x1f, 0x8180);</span></span><br><span class="line">                phy_write(dev, 0x16, 0x202);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return 0;</span><br></pre></td></tr></table></figure></p><h2 id="設定-ksz8863rll"><a href="#設定-ksz8863rll" class="headerlink" title="設定 ksz8863rll"></a>設定 ksz8863rll</h2><h3 id="MDIO-相關討論"><a href="#MDIO-相關討論" class="headerlink" title="MDIO 相關討論"></a>MDIO 相關討論</h3><p>一開始 HW 的電路是與 micrel 代理商的 FAE 討論出使用 SPI 進行設定<br>之後查詢　datasheet 知道這顆 IC 除了支援 SPI 外，還有支援 I2C 以及 MDIO</p><p>因為如果要透過 spi 介面來進行初始化的話， <strong>kernel 就需要加入 spi interface 的 driver</strong> ，對我來說<br>可能會拉長開發時間。因此與 Ted 討論後，認為應可以使用 default 的介面來設定 ksz8863rll</p><p>剛開始設計完後，發現 phy 無法認到 phy id，之後 FAE 請我們先檢查兩個 port 是否相通，如果初始化使用預設設定，並連通兩個同網段的網路，應該是可以連通才是</p><blockquote><p>[name=KSZ8863RLL FAE]<br>Dear Duncan,<br>這是我們新官網上KSZ8863RLL 的連結:<br><a href="http://www.microchip.com/wwwproducts/en/ksz8863" target="_blank" rel="noopener">http://www.microchip.com/wwwproducts/en/ksz8863</a><br>至於你們家S/W認不到PHY的部分,可以請你先確認一件事,RMII 那邊先不看<br>先確認另外兩個port是否有相通,如果有通表示KSZ8863RLL應該是沒問題,就是RMII對MAC這邊的問題.<br>另外一個可以你們S/W RD 提供Linux kernel log file,我請我們原廠幫他確認是否有其他建議.<br>如果可以提供給我分機聯繫上會比較方便.</p></blockquote><p>之後 <strong>確認可以連通</strong> ，晶片有些許溫度，應該是有進入工作狀態</p><p>不過將 mdio 電路修改還不夠，花了一點時間，找到了以下的資訊<br><a href="https://blog.csdn.net/yimiyangguang1314/article/details/43759695" target="_blank" rel="noopener">https://blog.csdn.net/yimiyangguang1314/article/details/43759695</a></p><p>這篇雖然不是 i.MX6 ，不過也有提到介面初始化的重點，mdio 就是所謂的 SMI 介面，需要控制 pin 腳去修改模式，根據 ksz8863rll datasheet 可以看到<br><img src="https://i.imgur.com/wc2nvK6.png" alt=""><br>在最下方有提到，<code>[P2LED1, P2LED0] = [1, 1]</code> 為 SMI/MIIM mode，因此請 Duncan 將電路的 P45 P46 改成 pull-high 後，就要修改 kernel 設定，在修改之前，我們要知道 mdio address 才可以實行</p><h3 id="mdio-address"><a href="#mdio-address" class="headerlink" title="mdio address"></a>mdio address</h3><p>datasheet 初始值如下，也可以透過 mdio 進行設置<br><img src="https://i.imgur.com/7k8f4ep.png" alt=""><br>太好了！初始值為 0x01，因為 ksz8081 的 phy address = 0x0，這樣就不會因為衝突而需要重新設定它，後面還有提到 Port2 PHY address = Port 1 PHY address + 1 = 0x2，這樣我們就可以透過 phytest 來取得更多 ic 的資訊了</p><h3 id="使用-phytest-來設定數值或取得-id"><a href="#使用-phytest-來設定數值或取得-id" class="headerlink" title="使用 phytest 來設定數值或取得 id"></a>使用 phytest 來設定數值或取得 id</h3><p>phytest 的相關資訊</p><p>repo: <a href="mailto:git@192.168.1.178" target="_blank" rel="noopener">git@192.168.1.178</a>:yocto/packages_test.git<br>binary source: packages_test/src/phytest<br>shell script: packages_test/scripts/phytest/ksz8081 or ksz8863rll</p><p>我們從下圖可以獲得 reigister 的一些慨述<br><img src="https://i.imgur.com/U0dyDt6.png" alt=""></p><p>可得知<br><strong>phy id 1 需要讀取 phyad = 0x1, regad = 0x2, 0x3<br>phy id 2 需要讀取 phyad = 0x2, regad = 0x2, 0x3</strong></p><p>之後我們可以透過 phytest 取得晶片 id，使用 phytest 取得的方式為<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/root/phytest &lt;interface&gt; &lt;reg&gt;</span><br><span class="line">example:</span><br><span class="line">/root/phytest eth1 0x02  &lt;---read phy 1 id (high)</span><br></pre></td></tr></table></figure></p><p>若再 devicetree 帶入 phyad 後確實可以獲得，不過這個對我們而言不是很重要，重要的是，要如何將兩個phy都可以自動改成 auto linked-up，不需要插入網路線後就可以取得 link status</p><h3 id="加入-fixed-link-來啟動-auto-linked-up"><a href="#加入-fixed-link-來啟動-auto-linked-up" class="headerlink" title="加入 fixed-link 來啟動 auto linked-up"></a>加入 fixed-link 來啟動 auto linked-up</h3><p>Ted 查出可以使用 fix-linked 的語法進行調整<br>kernel主要修改如下</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/arch/arm/boot/dts/imx6ul.dts b/arch/arm/boot/dts/imx6ul.dts</span><br><span class="line">index a3afe8e..d5da597 100644</span><br><span class="line"><span class="comment">--- a/arch/arm/boot/dts/imx6ul.dts</span></span><br><span class="line"><span class="comment">+++ b/arch/arm/boot/dts/imx6ul.dts</span></span><br><span class="line"><span class="meta">@@ -45,10 +45,12 @@</span></span><br><span class="line">        pinctrl-names = "default";</span><br><span class="line">        pinctrl-0 = &lt;&amp;pinctrl_enet2&gt;;</span><br><span class="line">        phy-mode = "rmii";</span><br><span class="line"><span class="deletion">-        phy-handle = &lt;&amp;ethphy1&gt;;</span></span><br><span class="line">         status = "okay";</span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="addition">+       fixed-link &#123;</span></span><br><span class="line"><span class="addition">+             speed = &lt;100&gt;;</span></span><br><span class="line"><span class="addition">+             full-duplex;</span></span><br><span class="line"><span class="addition">+             pause;</span></span><br><span class="line"><span class="addition">+       &#125;;</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>其中 phy-handle 移除是因為：兩個 phy 接上去都需要自動 link-up，而加入了 fixed-link，就可以自動執行  link-up 動作，描述的介紹都在 <strong>Documentation/devicetree/bindings/net/fixed-link.txt</strong><br>這樣就可以初始化完成，關閉 spi driver 與其他不相關設定</p><h3 id="ENET-REF-TX-CLK-的設置與確認-RX-ER-的設置"><a href="#ENET-REF-TX-CLK-的設置與確認-RX-ER-的設置" class="headerlink" title="ENET_REF_TX_CLK 的設置與確認 RX_ER 的設置"></a>ENET_REF_TX_CLK 的設置與確認 RX_ER 的設置</h3><p>這部份為了要 work 也是花了不少時間，因為雖然 mdio 那部份看似已經設定完成，但是封包依舊沒有辦法在進入系統後 ping 出去，表示軔體設置或是硬體電路還是有問題需要解決，因此我們將注意力轉到 reference clock 身上</p><p>之後與 KSZ8863 vendor FAE 討論後，FAE 誤會了我們的需求，因此我們將電路改成跟 IR 系列相同的電路<br><img src="https://i.imgur.com/ttIZFRe.png" alt=""></p><p>由上圖我們得知，我們透過 X1/X2 振盪出一個頻率 50MHz 的 Reference clock，之後再將 REF_CLK 同步到 i.MX6ULL 以及 KSZ8863RLL 上</p><p>因此我們需要修改 “Other Chip” 也就是 i.MX6ULL 的 REF_CLK 方向，將其設成 input<br>設定的方式……當時有點忘記有沒有針對此部份進行設定了，不過我們知道，還有另一種 clk 傳遞方式，如下圖：<br><img src="https://i.imgur.com/NJx0sJl.png" alt=""></p><p>因為之前的 clk 預設都是設定成 output，因此我跟 HW 想說，好！把 SMTXD2 SMTXD3 都設定成 pull down，來進行嘗試，結果，也是沒有辦法運作，因此我們去比對 ksz8081 與 ksz8863rll 的差異，發現 RX_ER 這隻腳似乎不一樣，8081 有接上，而 8863 是空接的狀態，因此我請 duncan 將 pin RX_ER 接到 pin 24 (SMTXER3)，之後用之前的 kernel 初始數值竟然可以 work了！！，但這個方式很奇怪，因為有兩個部份跟 IR 系列的電路不同</p><ul><li><strong>REF_CLK 的方向不對</strong>，我們不是透過 SMRXD3 輸出 50MHz clock 給 i.MX6，而是從 i.MX6 輸出50MHz</li><li>IR系列並<strong>沒有接上 RX_ER 這隻 pin</strong></li></ul><p>針對這個問題，我們將問題與電路傳給 i.MX6 的 FAE，請他給予協助，我們希望可以透過軟體來處理這個問題<br>之後我們將 RX_ER 的阻值進行修改</p><blockquote><p>[name=freescale FAE]<br>Device tree</p><p>MX6UL_PAD_ENET2_RX_ER__ENET2_RX_ER        0x1b0b0</p><p>Change to</p><p>MX6UL_PAD_ENET2_RX_ER__ENET2_RX_ER        0x130b0</p></blockquote><p>我們將 RX_ER 透過軟體強制 pull-down <strong>最後是有效果的</strong>，因此我們只剩下 REF_CLK 需要解決，因為我們希望電路可以與 IR 系列相同</p><p>這時，我查到 reference manual 有一個部份是可以處理 reference clk 的相關設定的<br><img src="https://i.imgur.com/uYOGzyJ.png" alt=""></p><p>就是這個了 GPR register!!要修改<br>clk 來源設成 external<br><img src="https://i.imgur.com/3wWJRiH.png" alt=""><br>clk 方向設成 input<br><img src="https://i.imgur.com/90DObbO.png" alt=""></p><p>針對以上，好！！我們只要針對 bit18 以及 bit14 進行修正就可以了</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/arch/arm/mach-imx/mach-imx6ul.c b/arch/arm/mach-imx/mach-imx6ul.c</span><br><span class="line">index 7da3a79..66bb082 100644</span><br><span class="line"><span class="comment">--- a/arch/arm/mach-imx/mach-imx6ul.c</span></span><br><span class="line"><span class="comment">+++ b/arch/arm/mach-imx/mach-imx6ul.c</span></span><br><span class="line">@@ -173,9 +173,14 @@ static void __init imx6ul_enet_clk_init(void)</span><br><span class="line">        struct regmap *gpr;</span><br><span class="line"></span><br><span class="line">        gpr = syscon_regmap_lookup_by_compatible("fsl,imx6ul-iomuxc-gpr");</span><br><span class="line"><span class="deletion">-       if (!IS_ERR(gpr))</span></span><br><span class="line"><span class="deletion">-               regmap_update_bits(gpr, IOMUXC_GPR1, IMX6UL_GPR1_ENET_CLK_DIR,</span></span><br><span class="line"><span class="deletion">-                               IMX6UL_GPR1_ENET_CLK_OUTPUT);</span></span><br><span class="line"><span class="addition">+       if (!IS_ERR(gpr)) &#123;</span></span><br><span class="line"><span class="addition">+               /* Set enet1 reference clock as output (enet2 as input) */</span></span><br><span class="line"><span class="addition">+               regmap_update_bits(gpr, IOMUXC_GPR1, IMX6UL_GPR1_ENET1_CLK_DIR,</span></span><br><span class="line"><span class="addition">+                               IMX6UL_GPR1_ENET1_CLK_OUTPUT);</span></span><br><span class="line"><span class="addition">+               /* Use external clock as enet2 reference clock */</span></span><br><span class="line"><span class="addition">+               regmap_update_bits(gpr, IOMUXC_GPR1, IMX6UL_GPR1_ENET2_CLK_SEL,</span></span><br><span class="line"><span class="addition">+                               IMX6UL_GPR1_ENET2_CLK_SET_EXTERNAL);</span></span><br><span class="line"><span class="addition">+       &#125;</span></span><br><span class="line">        else</span><br><span class="line">                pr_err("failed to find fsl,imx6ul-iomux-gpr regmap\n");</span><br><span class="line"></span><br><span class="line">diff --git a/include/linux/mfd/syscon/imx6q-iomuxc-gpr.h b/include/linux/mfd/syscon/imx6q-iomuxc-gpr.h</span><br><span class="line">index 96230ad..1bf91c8 100644</span><br><span class="line"><span class="comment">--- a/include/linux/mfd/syscon/imx6q-iomuxc-gpr.h</span></span><br><span class="line"><span class="comment">+++ b/include/linux/mfd/syscon/imx6q-iomuxc-gpr.h</span></span><br><span class="line"><span class="meta">@@ -490,5 +490,7 @@</span></span><br><span class="line"> #define IMX6UL_GPR1_ENET2_CLK_OUTPUT           (0x1 &lt;&lt; 18)</span><br><span class="line"> #define IMX6UL_GPR1_ENET_CLK_DIR               (0x3 &lt;&lt; 17)</span><br><span class="line"> #define IMX6UL_GPR1_ENET_CLK_OUTPUT            (0x3 &lt;&lt; 17)</span><br><span class="line"><span class="addition">+#define IMX6UL_GPR1_ENET2_CLK_SEL              (0x1 &lt;&lt; 14)</span></span><br><span class="line"><span class="addition">+#define IMX6UL_GPR1_ENET2_CLK_SET_EXTERNAL     (0x1 &lt;&lt; 14)</span></span><br><span class="line"></span><br><span class="line"> #endif /* __LINUX_IMX6Q_IOMUXC_GPR_H */</span><br></pre></td></tr></table></figure><p>好，這樣設定的動作就是 enet1 clk 都是設成 output，而使用 ksz8863RLL 的 enet2，reference clk 則是設成 input(default) 並且將clk source 設定成 <strong>EXTERNAL CLOCK</strong></p><p>之後還是有詢問 Apollo</p><blockquote><p>[name=Weintek-Timmyliu]<br>若將 ENET2_REF_CLK2 設成 input 的話，那 MX6UL_PAD_ENET2_TX_CLK__ENET2_REF_CLK2 的阻值是否要改？？<br>並幫我確認以上的 GPR register 是否設定有誤</p></blockquote><p>之後 APOLLO 回信</p><blockquote><p>[name=APOLLO]<br>On 2018年05月17日 15:11, APOLLO CHANG wrote:</p><p>MX6UL_PAD_ENET2_TX_CLK__ENET2_REF_CLK2 0x4001b031</p><p>Change to</p><p>MX6UL_PAD_ENET2_TX_CLK__ENET2_REF_CLK2 0x0a0b1</p></blockquote><p>之後 duncan 將此部份的電路短路，就可以運作了</p><p><img src="https://i.imgur.com/21tcLz9.png" alt=""></p><p>大功告成，ksz8863rll 大致上設定完成</p><h3 id="針對-KSZ8863RLL-vendor-FAE-的-PHY-mode-以及-MAC-mode-進行解釋"><a href="#針對-KSZ8863RLL-vendor-FAE-的-PHY-mode-以及-MAC-mode-進行解釋" class="headerlink" title="針對 KSZ8863RLL vendor FAE 的 PHY mode 以及 MAC mode 進行解釋"></a>針對 KSZ8863RLL vendor FAE 的 PHY mode 以及 MAC mode 進行解釋</h3><p>RLL 當然是走 rmii interface ，所以 datasheet 我們只要看 rmii signal connections 就可以了<br><img src="https://i.imgur.com/JAgKHEf.png" alt=""></p><p>這邊提到的是：PHY-MAC 以及 MAC-MAC 連線的兩種模式</p><p>FAE 並沒有強調這兩個 mode 的意思，但根據我們研究下來，發現 MAC-MAC 的意思就是晶片的 MAC 接過去的對象，而我們的對象就是 8863RLL MAC2 接出去的目標，也就是 i.MX6ULL 的 MAC controller，因此接線必須參考右邊，左邊則是如果 KSZ8863RLL 接出去的是 External PHY IC，則接線就依據左邊，所以我們可以知道 RX_ER 是可以不用接的</p><h3 id="Ping-大封包會-ping-不出去"><a href="#Ping-大封包會-ping-不出去" class="headerlink" title="Ping 大封包會 ping 不出去"></a>Ping 大封包會 ping 不出去</h3><p>原因是因為 HW 電路將 8081 與 8863 都用相同的電容大小處理，之後拿掉 REF_CLK 電容後就可以穩定的 ping</p><h3 id="硬體修改如下"><a href="#硬體修改如下" class="headerlink" title="硬體修改如下"></a>硬體修改如下</h3><ol><li>原本SPI的設定改成SMI mode</li><li>原本8863 REFCLK output與REFCLK IN是斷開的，後來用0R把它接上</li><li>REFCLK上的電容拿掉</li></ol><h3 id="軔體修改如下"><a href="#軔體修改如下" class="headerlink" title="軔體修改如下"></a>軔體修改如下</h3><ol><li>修改 REF_CLK input resistor value</li><li>RX_ER 設 pulldown</li><li>set enet2_ref_clk as input</li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://community.nxp.com/thread/323536" target="_blank" rel="noopener">https://community.nxp.com/thread/323536</a><br><a href="http://www.microchip.com/wwwproducts/en/ksz8863" target="_blank" rel="noopener">http://www.microchip.com/wwwproducts/en/ksz8863</a></p><p><a href="https://www.spinics.net/lists/netdev/msg265530.html" target="_blank" rel="noopener">https://www.spinics.net/lists/netdev/msg265530.html</a><br><a href="http://ww1.microchip.com/downloads/en/softwarelibrary/ksz_switch_usage_guide/micrel_switch_usage_guide.pdf" target="_blank" rel="noopener">http://ww1.microchip.com/downloads/en/softwarelibrary/ksz_switch_usage_guide/micrel_switch_usage_guide.pdf</a></p><p><a href="http://www.variwiki.com/index.php?title=DART-6UL_Ethernet" target="_blank" rel="noopener">http://www.variwiki.com/index.php?title=DART-6UL_Ethernet</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文章針對 ksz8863rll 以及 ksz8081 在 i.MX6ULL 平台上進行 linux driver porting&lt;br&gt;閱讀全文以看更詳細的說明以及終於遇到的問題與心得&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://m033010041.github.io/tags/Linux/"/>
    
      <category term="Embedded Linux" scheme="https://m033010041.github.io/tags/Embedded-Linux/"/>
    
      <category term="i.MX6ULL" scheme="https://m033010041.github.io/tags/i-MX6ULL/"/>
    
      <category term="KSZ8863RLL" scheme="https://m033010041.github.io/tags/KSZ8863RLL/"/>
    
  </entry>
  
  <entry>
    <title>AM335X U-Boot SPL 的 CCS 環境建置與除錯方法整理</title>
    <link href="https://m033010041.github.io/2018/01/29/am335x-spl-css/"/>
    <id>https://m033010041.github.io/2018/01/29/am335x-spl-css/</id>
    <published>2018-01-29T09:11:20.000Z</published>
    <updated>2018-12-21T15:12:54.476Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/DcJfYlo.png" alt="Imgur"></p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工作時，工作任務中需要修改 U-boot 前端的程式碼，也就是 xloader (MLO)，這一個部分雖然可以透過 printf() 進行除錯，但是對於某些方面還是會發生問題，使用 CCS 進行除錯可以了解暫存器的存儲、組合語言的單部執行，以利我們可以更快的找到問題點，此文章紀錄了 CCS 環境建置與建議的除錯方法進行整理</p><p><a href="https://read01.com/zh-tw/a0dm7j.html#.Wmp5IHVuYbx" target="_blank" rel="noopener">參考資料</a> ，若有不懂的地方可以翻這個網站參考</p><p>TI 原廠也有提供 <a href="http://www.ti.com.cn/cn/lit/an/zhca539/zhca539.pdf" target="_blank" rel="noopener">簡體中文的使用手冊</a> 可以查找</p><hr><h2 id="Outline"><a href="#Outline" class="headerlink" title="Outline"></a>Outline</h2><ul><li><a href="#軟體安裝流程">軟體安裝流程</a><ul><li><a href="#Download-CCS">Download CCS</a></li><li><a href="#Install-Sitara-Series-Device-Support">Install Sitara Series Device Support</a></li></ul></li><li><a href="#建立-Project">建立 Project</a></li><li><a href="#JTAG-設定流程">JTAG 設定流程</a><ul><li><a href="#製作-JTAG-ccxml-檔案">製作 JTAG .ccxml 檔案</a></li><li><a href="#Connect-JTAG-to-MT6071iE">Connect JTAG to MT6071iE</a></li><li><a href="#build-debug-MLO">Build debug MLO</a></li><li><a href="#Load-Memory-Load-raw-data-to-cpu-memory">Load Memory (Load raw data to cpu memory)</a></li><li><a href="#Load-Symbol">Load Symbol</a></li><li><a href="#設置中斷點">設置中斷點</a></li></ul></li></ul><hr><h3 id="Download-CCS"><a href="#Download-CCS" class="headerlink" title="Download CCS"></a>Download CCS</h3><ul><li>LINK: <a href="http://processors.wiki.ti.com/index.php/Download_CCS" target="_blank" rel="noopener">http://processors.wiki.ti.com/index.php/Download_CCS</a></li><li>找最新版本</li><li>之後選擇 offline download 如圖<br><img src="https://i.imgur.com/QxCyuH6.png" alt="Imgur"></li><li>download 後解壓縮，進入資料夾內部執行<br><code>./ccs_setup_linux64_7.4.0.00015.bin</code></li><li>安裝最後一步，可勾選 create desktop icon，比較方便執行</li></ul><h3 id="Install-Sitara-Series-Device-Support"><a href="#Install-Sitara-Series-Device-Support" class="headerlink" title="Install Sitara Series Device Support"></a>Install Sitara Series Device Support</h3><ul><li><p>GOTO: <a href="http://processors.wiki.ti.com/index.php/File:Bookmarks_device_support.zip" target="_blank" rel="noopener">http://processors.wiki.ti.com/index.php/File:Bookmarks_device_support.zip</a></p></li><li><p>選擇最新的 Bookmark_device_support.zip 下載，下載完後解壓縮到你喜愛的路徑</p></li><li>開啟 CCSv7，執行上方工具列 Windows -&gt; Perferences</li><li>點開後，左側欄位選擇 Install/Update -&gt; Available Software Sites. -&gt; 點擊 Import -&gt; 選擇目標xml file</li></ul><p><img src="https://i.imgur.com/DcJfYlo.png" alt="Imgur"></p><ul><li>引入後，不要忘了點擊上方工具列 Help -&gt; Check for Updates 應該就會跳出安裝圖示了</li><li>選擇 Sitara Device Support 來更新套件</li></ul><p>若無法透過上面安裝</p><ul><li>不需要載任何的 device_support 檔案，直接點擊上方列 Help -&gt; Install New Software</li><li>Work with 填入網址 <code>http://software-dl.ti.com/ccs/esd/device_support_sitara</code></li><li>將全部的套件安裝好即可</li><li>以上設定完成</li></ul><h2 id="建立-Project"><a href="#建立-Project" class="headerlink" title="建立 Project"></a>建立 Project</h2><ul><li>開啟 CCSv7</li><li>點擊 File -&gt; New -&gt; Import</li><li>選擇 C/C++ -&gt; Existing Code as Makefile Project -&gt; Next<br><img src="https://i.imgur.com/4yfMlq2.png" alt=""></li><li>選擇 uboot 的路徑 -&gt; 確認後按下 Finish<br><img src="https://i.imgur.com/5b7QfZc.png" alt=""></li><li>建立完成</li></ul><h2 id="JTAG-設定流程"><a href="#JTAG-設定流程" class="headerlink" title="JTAG 設定流程"></a>JTAG 設定流程</h2><h3 id="製作-JTAG-ccxml-檔案"><a href="#製作-JTAG-ccxml-檔案" class="headerlink" title="製作 JTAG .ccxml 檔案"></a>製作 JTAG .ccxml 檔案</h3><ul><li>將 XDS100v2 JTAG Debug tool 接到電腦上，另一端接上</li><li>上方工具列 File -&gt; New -&gt; Target Configuration File</li><li>看是否要修改名稱，我是直接命名成 XDS100V2.ccxml，修改完後點擊 Next</li><li>Connection 選擇 XDS100v2 USB Debug Probe</li><li>若 Device Support有安裝成功，Board or Device 可選到 AM3352</li><li>Save Configuration 點擊 Save 後 Test Connection 會跳出按鈕可以點擊<br><img src="https://i.imgur.com/kmTy6p8.png" alt=""></li><li>點擊 Test Connection 測試成功的內容可以看到<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-----[Perform the Integrity scan-test on the JTAG IR]------------------------</span></span><br><span class="line"></span><br><span class="line">This test will use blocks of 64 32-bit words.</span><br><span class="line">This test will be applied just once.</span><br><span class="line"></span><br><span class="line">Do a test using 0xFFFFFFFF.</span><br><span class="line">Scan tests: 1, skipped: 0, failed: 0</span><br><span class="line">Do a test using 0x00000000.</span><br><span class="line">Scan tests: 2, skipped: 0, failed: 0</span><br><span class="line">Do a test using 0xFE03E0E2.</span><br><span class="line">Scan tests: 3, skipped: 0, failed: 0</span><br><span class="line">Do a test using 0x01FC1F1D.</span><br><span class="line">Scan tests: 4, skipped: 0, failed: 0</span><br><span class="line">Do a test using 0x5533CCAA.</span><br><span class="line">Scan tests: 5, skipped: 0, failed: 0</span><br><span class="line">Do a test using 0xAACC3355.</span><br><span class="line">Scan tests: 6, skipped: 0, failed: 0</span><br><span class="line">All of the values were scanned correctly.</span><br><span class="line"></span><br><span class="line">The JTAG IR Integrity scan-test has succeeded.</span><br></pre></td></tr></table></figure></li></ul><p>看到任何一個 fail 都要除錯</p><h3 id="Connect-JTAG-to-MT6071iE"><a href="#Connect-JTAG-to-MT6071iE" class="headerlink" title="Connect JTAG to MT6071iE"></a>Connect JTAG to MT6071iE</h3><ul><li>之後點擊 View -&gt; Target Configuration</li><li><p>選擇 User Defined -&gt; 檔案按右鍵 -&gt; Launch Selected Configuration</p><div style="text-align: center"><br><img src="https://i.imgur.com/ek4GoEU.png"><br></div></li><li><p>之後會跳到 debug 頁面，應該會看到以下圖片<br><img src="https://i.imgur.com/xcFg2KW.png" alt=""></p></li><li>選擇 Probe_0/CortexA8(Disconnected: Unknown) (通常是第2項)</li><li>右鍵選擇 Connect Target</li><li>連線完成</li></ul><p>連線未成功通常是沒有接穩，或是剛剛的 Test Connection 沒有通過</p><h3 id="build-debug-MLO"><a href="#build-debug-MLO" class="headerlink" title="build debug MLO"></a>build debug MLO</h3><ul><li><p>修改 ti_uboot/config.mk</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/config.mk b/config.mk</span><br><span class="line">index b7cd481..3495099 100644</span><br><span class="line"><span class="comment">--- a/config.mk</span></span><br><span class="line"><span class="comment">+++ b/config.mk</span></span><br><span class="line">@@ -60,7 +60,7 @@ PLATFORM_LDFLAGS =</span><br><span class="line"></span><br><span class="line"> #########################################################################</span><br><span class="line"></span><br><span class="line"><span class="deletion">-HOSTCFLAGS     = -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer \</span></span><br><span class="line"><span class="addition">+HOSTCFLAGS     = -Wall -Wstrict-prototypes -fomit-frame-pointer \</span></span><br><span class="line">                  $(HOSTCPPFLAGS)</span><br><span class="line"> HOSTSTRIP      = strip</span><br><span class="line"></span><br><span class="line">@@ -315,8 +315,8 @@ export      CONFIG_SYS_TEXT_BASE PLATFORM_CPPFLAGS PLATFORM_RELFLAGS CPPFLAGS CFLAGS</span><br><span class="line"></span><br><span class="line"> # Allow boards to use custom optimize flags on a per dir/file basis</span><br><span class="line"> BCURDIR = $(subst $(SRCTREE)/,,$(CURDIR:$(obj)%=%))</span><br><span class="line"><span class="deletion">-ALL_AFLAGS = $(AFLAGS) $(AFLAGS_$(BCURDIR)/$(@F)) $(AFLAGS_$(BCURDIR))</span></span><br><span class="line"><span class="deletion">-ALL_CFLAGS = $(CFLAGS) $(CFLAGS_$(BCURDIR)/$(@F)) $(CFLAGS_$(BCURDIR))</span></span><br><span class="line"><span class="addition">+ALL_AFLAGS = $(AFLAGS) $(AFLAGS_$(BCURDIR)/$(@F)) $(AFLAGS_$(BCURDIR)) -g</span></span><br><span class="line"><span class="addition">+ALL_CFLAGS = $(CFLAGS) $(CFLAGS_$(BCURDIR)/$(@F)) $(CFLAGS_$(BCURDIR)) -g</span></span><br><span class="line"> EXTRA_CPPFLAGS = $(CPPFLAGS_$(BCURDIR)/$(@F)) $(CPPFLAGS_$(BCURDIR))</span><br><span class="line"> ALL_CFLAGS += $(EXTRA_CPPFLAGS)</span><br></pre></td></tr></table></figure></li><li><p>執行 <code>./build.sh</code> 產生執行檔</p></li><li><p>可以看到產生幾個檔案</p><ul><li>MLO：放在 ti_uboot 或是 ti_uboot/am335x</li><li>u-boot-spl：放在 ti_uboot/am335x/spl <strong>是 MLO 的 symbol file</strong> 非常重要</li><li>u-boot-spl.bin：放在 ti_uboot/am335x/spl 是 MLO 的 raw data，<strong>可用於直接 loading 到 CPU 的 mem 中</strong></li></ul></li><li><p>我們將會專注在 u-boot-spl.bin 以及 u-boot-spl 這兩支檔案</p></li></ul><h3 id="Load-Memory-Load-raw-data-to-cpu-memory"><a href="#Load-Memory-Load-raw-data-to-cpu-memory" class="headerlink" title="Load Memory (Load raw data to cpu memory)"></a>Load Memory (Load raw data to cpu memory)</h3><ul><li><p>load mem 之前，我們要先看一下 spl 執行的 start address</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_SPL_TEXT_BASE            0x402F0400</span></span><br></pre></td></tr></table></figure></li><li><p>datasheet 也有給予資料可參考<br><img src="https://i.imgur.com/4DQ3K3C.png" alt=""></p></li><li>回到 CCS，此時 JTAG 應該是處於 <strong>已連線</strong> 的狀況</li><li>點擊上方工具列 tool -&gt; Load Memory</li><li>選擇 u-boot-spl.bin raw data -&gt; File Type select Binary -&gt; Next</li><li><p><img src="https://i.imgur.com/zhNIAkx.png" alt=""></p></li><li><p>Start Address 填入 0x402f0400 -&gt; Finish<br><img src="https://i.imgur.com/zw3fr2t.png" alt=""></p></li><li><p>上面工具列 View -&gt; Disassambly 可以看到目前的PC位置</p></li><li><p>或是查看上方的 Registers -&gt; Core Registers -&gt; PC (program counter)<br><img src="https://i.imgur.com/D8HYOgv.png" alt=""></p></li><li><p>確認無誤後，Load mem 完成</p></li></ul><h3 id="Load-Symbol"><a href="#Load-Symbol" class="headerlink" title="Load Symbol"></a>Load Symbol</h3><ul><li>這邊就簡單許多了，直接點擊上方 Run -&gt; Load -&gt; Load Symbol</li><li>檔案選擇 <code>ti_uboot/am335x/spl/u-boot-spl</code> 後按下OK即可</li><li>之後視窗會出現 start.S 的頁面，此時已經可以開始設定中斷點了</li><li>Load Symbol 完成</li></ul><h3 id="設置中斷點"><a href="#設置中斷點" class="headerlink" title="設置中斷點"></a>設置中斷點</h3><ul><li>假設我要在其中一個指令增加中斷點的話，務必在該程式碼按下右鍵 -&gt; Break Point (Code Composer Studio) -&gt; Break Point</li><li>右上方的 Breakpoint 應該會跳出，並且Action 設定成 <strong>“Remain Halted”</strong></li><li>按下 Run 的執行鈕應該就會停在該程式碼了</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/DcJfYlo.png&quot; alt=&quot;Imgur&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://m033010041.github.io/tags/Linux/"/>
    
      <category term="Embedded Linux" scheme="https://m033010041.github.io/tags/Embedded-Linux/"/>
    
      <category term="am335x" scheme="https://m033010041.github.io/tags/am335x/"/>
    
  </entry>
  
  <entry>
    <title>2017 暑期系統軟體課程台北場(課前測驗題)</title>
    <link href="https://m033010041.github.io/2017/07/17/2017SysProg/"/>
    <id>https://m033010041.github.io/2017/07/17/2017SysProg/</id>
    <published>2017-07-17T05:33:42.000Z</published>
    <updated>2019-06-09T08:56:57.813Z</updated>
    
    <content type="html"><![CDATA[<p>上班之餘，看到了 jserv 的軟體課程，花了一點時間看看。以下是我寫程式途中所的開發筆記與成果</p><p>題目詳細內容：<a href="https://hackmd.io/s/B1wb8CyHb" target="_blank" rel="noopener">課前測驗題</a><br>程式內容(Github)：<a href="https://github.com/m033010041/2017_sysprog" target="_blank" rel="noopener">請點我</a></p><a id="more"></a><h2 id="Question-01"><a href="#Question-01" class="headerlink" title="Question 01"></a>Question 01</h2><p>以下是題目給予的程式碼：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="keyword">uint32_t</span> func(<span class="keyword">uint32_t</span> x) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> n = x;</span><br><span class="line">    n = ((n &amp; <span class="number">0xffff0000</span>) &gt;&gt; <span class="number">16</span>) | ((n &amp; <span class="number">0x0000ffff</span>) &lt;&lt; <span class="number">16</span>);</span><br><span class="line">    n = ((n &amp; <span class="number">0xff00ff00</span>) &gt;&gt;  <span class="number">8</span>) | ((n &amp; <span class="number">0x00ff00ff</span>) &lt;&lt;  <span class="number">8</span>);</span><br><span class="line">    n = ((n &amp; <span class="number">0xf0f0f0f0</span>) &gt;&gt;  <span class="number">4</span>) | ((n &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt;  <span class="number">4</span>);</span><br><span class="line">    n = ((n &amp; <span class="number">0xcccccccc</span>) &gt;&gt;  <span class="number">2</span>) | ((n &amp; <span class="number">0x33333333</span>) &lt;&lt;  <span class="number">2</span>);</span><br><span class="line">    n = ((n &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt;  <span class="number">1</span>) | ((n &amp; <span class="number">0x55555555</span>) &lt;&lt;  <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="我的解答："><a href="#我的解答：" class="headerlink" title="我的解答："></a>我的解答：</h3><p>仔細觀察後可以發現這個 function 會將數值 x 的 bit 從大範圍至小範圍進行交換，這種算是有效率的 bit reverse algorithm</p><p>bit reverse algorithm 最常用在快速傅立葉轉換 (FFT) 中，裡面有一個重要的步驟，就是透過 butterfly 網路進行頻率降取樣 (decimation-in-frequency) 的時候，需要變換輸入點的編號 (order)</p><p><img src="https://i.imgur.com/KFqpUCV.gif" alt="8 point FFT"></p><p>以下是透過 for/while 所改寫的 bit reverse function</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="keyword">uint32_t</span> func1(<span class="keyword">uint32_t</span> x) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> r = x &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> shift = <span class="keyword">sizeof</span>(x) * <span class="number">8</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(x = x &gt;&gt; <span class="number">1</span>; x; x&gt;&gt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r = r &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        r = r | (x &amp; <span class="number">1</span>);</span><br><span class="line">        shift--;</span><br><span class="line">    &#125;</span><br><span class="line">    r &lt;&lt;= shift;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這個方式就是先觀察 x 是否為 0 ，若不為 0 就進行右移，存入 r 中後進行左移，當 x = 0 時看還剩下多少需要左移的數量一次移完，這種寫法的好處是我 16 bit 的做法只要把 input/output 的宣告改掉即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="keyword">uint16_t</span> func2(<span class="keyword">uint16_t</span> x) &#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> r = x &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> shift = <span class="keyword">sizeof</span>(x) * <span class="number">8</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(x = x &gt;&gt; <span class="number">1</span>; x; x&gt;&gt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r = r &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        r = r | (x &amp; <span class="number">1</span>);</span><br><span class="line">        shift--;</span><br><span class="line">    &#125;</span><br><span class="line">    r &lt;&lt;= shift;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2#.E7.AE.97.E6.B3.95.E5.AE.9E.E7.8E.B0" target="_blank" rel="noopener">快速傅立葉轉換：bit reverse</a><br><a href="http://www.idi.ntnu.no/~elster/pubs/elster-bit-rev-1989.pdf" target="_blank" rel="noopener">fast bit reversal algorithm</a></p><h2 id="Question-02"><a href="#Question-02" class="headerlink" title="Question 02"></a>Question 02</h2><p>乘法器實作，其實看的範例的乘法器，那個 half_add()，似乎是全加器欸？</p><p>因為 <code>return half_add(sum, carry);</code> 補進去之後就變成了 ripple-carry adder 了</p><p>剛開始我的想法是，給定一個被乘數 a 和乘數 b，表示 a 會 <strong>被加 b 次</strong> ，由這個簡單的想法我可以把 code 寫成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> mul32(<span class="keyword">uint32_t</span> a, <span class="keyword">uint32_t</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> result=<span class="number">0</span>, i;</span><br><span class="line">    <span class="keyword">uint32_t</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=b; b; b&gt;&gt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)  <span class="comment">//if bit i is 1</span></span><br><span class="line">            result = half_add(result, (a&lt;&lt;j));</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但這樣似乎不符合 recurive 的規定，因此修改了程式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> mul32_recursive(<span class="keyword">uint32_t</span> a, <span class="keyword">uint32_t</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> half_add(((b&amp;<span class="number">1</span>)?a:<span class="number">0</span>), (mul32_recursive(a, b&gt;&gt;<span class="number">1</span>)&lt;&lt; <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這樣就大功告成囉～</p><h2 id="Question-05"><a href="#Question-05" class="headerlink" title="Question 05"></a>Question 05</h2><p>討論以下程式碼<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        fork();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   wait(<span class="literal">NULL</span>); wait(<span class="literal">NULL</span>); wait(<span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果將這個程式丟進 linux 執行後我們可以得到輸出的數值為 24，這個到底是什麼原因呢？理論上，<code>fork()</code> 執行 N 次，所產生的 process 數目應為 2^N^ - 1 個，因此此程式執行完後總共有 8 個 process (包含 main 程序)。</p><p>接下來我們討論 printf 的處理方式，printf 主要會 call <code>fprintf(stdout, &quot;...&quot;);</code></p><p>但是在 <a href="http://fanli7.net/a/bianchengyuyan/_NET/20120831/215063.html" target="_blank" rel="noopener">這篇文章</a> 中提到，<code>fork()</code> 執行時會先把資料丟到 <code>stdout</code> 的緩衝區，但是不會立即的觸發輸出，這個可能就是為什麼會輸出 24 的原因了</p><p>理論上所顯示的數目為 14 個，由下圖的分析可得知</p><p><img src="https://i.imgur.com/rpUw9JB.png" alt=""></p><p>因為 <code>fork()</code> 之後子程序會保留當下父程序的狀態，因此可以獲得 14 個 “-“ 符號，但是由於不會立即觸發 <code>stdout</code> 緩衝區，因此在    <code>fork()</code> 的當下其實 <code>stdout</code> 緩衝區的內容也一併被複製到子程序了，如下圖</p><p><img src="https://i.imgur.com/936j2Od.png" alt=""></p><p>因此輸出時會得到 24 個 “-“ 符號</p><p>喔對了，忘了補上如果直接觸發 <code>stdout</code> 緩衝區，其實只要透過 <code>&#39;\n&#39;</code> 這個字元就可以直接觸發 <code>stdout</code>，將結果直接印出來，我們只要修改 printf 即可獲得</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        fork();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-\n"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   wait(<span class="literal">NULL</span>); wait(<span class="literal">NULL</span>); wait(<span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這樣輸出就會變成是 14 個 “-“ 符號囉～</p><h3 id="參考資料-1"><a href="#參考資料-1" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="http://fanli7.net/a/bianchengyuyan/_NET/20120831/215063.html" target="_blank" rel="noopener">linux中fork（）函數詳解（原創！！實例講解）（轉載）</a></p><h2 id="Release-Note"><a href="#Release-Note" class="headerlink" title="Release Note"></a>Release Note</h2><p>三四題之後會在此文章補上<br>Q5 補上觸發緩衝區程式碼</p><p>comment</p><blockquote><p>This is Gugeegee.[name=劉安庭][color=#def29d]<br>[time=Mon, Jul 17, 2017 11:45 AM]<br>GitHub: <a href="https://github.com/m033010041/2017_sysprog" target="_blank" rel="noopener">https://github.com/m033010041/2017_sysprog</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上班之餘，看到了 jserv 的軟體課程，花了一點時間看看。以下是我寫程式途中所的開發筆記與成果&lt;/p&gt;
&lt;p&gt;題目詳細內容：&lt;a href=&quot;https://hackmd.io/s/B1wb8CyHb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;課前測驗題&lt;/a&gt;&lt;br&gt;程式內容(Github)：&lt;a href=&quot;https://github.com/m033010041/2017_sysprog&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;請點我&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="OS" scheme="https://m033010041.github.io/tags/OS/"/>
    
      <category term="system prog" scheme="https://m033010041.github.io/tags/system-prog/"/>
    
  </entry>
  
</feed>
