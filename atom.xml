<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Timmy的軟韌體開發筆記</title>
  
  <subtitle>累積經驗，分享經驗</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://m033010041.github.io/"/>
  <updated>2018-11-21T16:42:57.694Z</updated>
  <id>https://m033010041.github.io/</id>
  
  <author>
    <name>Timmy Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[讀書心得] The Linux Programming Interface 第 19 章：檔案監控事件</title>
    <link href="https://m033010041.github.io/2018/11/21/TLPI-inotify/"/>
    <id>https://m033010041.github.io/2018/11/21/TLPI-inotify/</id>
    <published>2018-11-21T01:59:28.127Z</published>
    <updated>2018-11-21T16:42:57.694Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inotify_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>wd;</span><br><span class="line">    <span class="keyword">uint32_t</span>mask;</span><br><span class="line">    <span class="keyword">uint32_t</span>cookie;</span><br><span class="line">    <span class="keyword">uint32_t</span>len;</span><br><span class="line">    <span class="keyword">char</span>name[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這一章節，主要是在了解應用程式為了知道監控物件 (object) 發生了哪些事件，需要能夠監視檔案以及目錄，像是說</p><ul><li>圖形化的檔案管理程式可以知道檔案何時從目前的正在顯示的目錄中新增或是刪除</li><li>一個守護程式 (又稱常駐程式, daemon) 可能會監視一個組態檔案觀察是否該檔案是否有被更動過</li></ul><p>從 kernel <code>v2.6.13</code> 開始，Linux 提供了 inotify 機制，接受應用程式監控檔案與目錄事件<br>inotify 機制取代了舊有的 dnotify 機制，最後會介紹 dnotify 並且解釋 inotify 為何比較好</p><h2 id="19-1-概觀"><a href="#19-1-概觀" class="headerlink" title="19.1 概觀"></a>19.1 概觀</h2><p>使用 inotify API 步驟</p><ol><li>先使用 <code>inotify_init()</code> 建立一個 inotify instance，之後會回傳一個檔案描述符 (file descriptor)</li><li>針對核心有興趣的檔案，使用 <code>inotify_add_watch()</code> 新增項目到所建立的 inotify instance 中，每個項目都有一個路徑名稱與監控事件集合，透過函式內的位元遮罩 (bit mask) 進行處理</li><li><code>inotify_add_watch()</code> 針對每一個監控項目，回傳一個監控描述符 (watch descriptor, wd)</li><li>透過 <code>read()</code> 操作讀取 inotify instance，每次成功 <code>read()</code> 後都會回傳一個以上的 <code>inotify_event</code> 結構</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inotify_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>wd;</span><br><span class="line">    <span class="keyword">uint32_t</span>mask;</span><br><span class="line">    <span class="keyword">uint32_t</span>cookie;</span><br><span class="line">    <span class="keyword">uint32_t</span>len;</span><br><span class="line">    <span class="keyword">char</span>name[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="19-2-inotify-API"><a href="#19-2-inotify-API" class="headerlink" title="19.2 inotify API"></a>19.2 inotify API</h2><h3 id="新增-inotify-instance"><a href="#新增-inotify-instance" class="headerlink" title="新增 inotify instance"></a>新增 inotify instance</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/inotify.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns file descriptor on success, or -1 on error */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inotify_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>回傳的 file descriptor 可以對於一個 inotify instance 進行操作</p><h3 id="新增監看項目，回傳監看描述符"><a href="#新增監看項目，回傳監看描述符" class="headerlink" title="新增監看項目，回傳監看描述符"></a>新增監看項目，回傳監看描述符</h3><p>根據上方的步驟，接下來我們會執行<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/inotify.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns watch descriptor (wd) on success, or -1 on error */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inotify_add_watch</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uint32_t</span> mask)</span></span>;</span><br></pre></td></tr></table></figure></p><p>此項目會對 fd 所參考的 inotify instance 新增一個監看項目，每一個監看項目有</p><ul><li>監看路徑</li><li>監看事件集合 (bit mask)<br><img src="/2018/11/21/TLPI-inotify/19_1.png" width="70%"></li><li><strong>若 pathname 為空</strong>，則 <code>inotify_add_watch()</code> 會建立一個新的監看項目並回傳一個非負值的 watch descriptor</li></ul><h3 id="移除監看項目"><a href="#移除監看項目" class="headerlink" title="移除監看項目"></a>移除監看項目</h3><p>若要移除 inotify instance 中的監看項目，會使用系統呼叫：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/inotify.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns 0 on success, or -1 on error */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inotify_rm_watch</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> wd)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="19-3-inotify-Events"><a href="#19-3-inotify-Events" class="headerlink" title="19.3 inotify Events"></a>19.3 inotify Events</h2><p>下圖為 inotify 事件列表，可以透過 <code>inotify_add_watch()</code> 中的 mask 參數識別要監視的 pathname 事件集合</p><ul><li>當權限、所有者、連結計數、擴充屬性、使用者 ID 或是群組 ID 等 metadata 資料改變時，會發生 <code>IN_ATTRIB</code> 事件</li><li>若目標監視刪除時，會發生 <code>IN_DELETE_SELF</code> 事件，若受監視是 <strong>目錄</strong> 且目錄中的其中一個檔案被刪除時，會發生 <code>IN_DELETE</code> 事件</li><li>若受監視的物件重新命名時，會發生 <code>IN_MOVE_SELF</code> 事件，若 <strong>監視目錄</strong> 中的其中一個物件重新命名時，會發生 <code>IN_MOVE_FROM</code> 與 <code>IN_MOVE_TO</code> 事件</li></ul><h2 id="19-4-Read-inotify-Event"><a href="#19-4-Read-inotify-Event" class="headerlink" title="19.4 Read inotify Event"></a>19.4 Read inotify Event</h2><p>使用 <code>read()</code> 進行讀取事件動作<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Max_Event10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_LEN(Max_Event * ((sizeof(struct inotify_event) + NAME_MAX + 1)))</span></span><br><span class="line"><span class="keyword">int</span> numRead;</span><br><span class="line"><span class="keyword">int</span> inotifyFd; <span class="comment">//From inotify_init()</span></span><br><span class="line"><span class="keyword">char</span> buf[BUF_LEN];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* In function */</span></span><br><span class="line">numRead = read(inotifyFd, buf, BUF_LEN);</span><br></pre></td></tr></table></figure></p><p>讀取一次的量為各事件發生時的數目<br>事件發生數目為 <code>numRead / (BUF_LEN/Max_Event)</code></p><p><img src="/2018/11/21/TLPI-inotify/19_2.png" width="70%"><br><code>inotify_add_watch()</code> 的 mask 可以帶入 <code>sys/inotify.h</code> 中的 <code>IN_ALL_EVENT</code> ，定義如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IN_ALL_EVENTS(IN_ACCESS | IN_MODIFY | IN_ATTRIB | IN_CLOSE_WRITE | \</span></span><br><span class="line"> IN_CLOSE_NOWRITE | IN_OPEN | IN_MOVED_FROM | \</span><br><span class="line"> IN_MOVED_TO | IN_DELETE | IN_CREATE | IN_DELETE_SELF)</span><br></pre></td></tr></table></figure><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><ol><li>add file / directory</li><li>modify file</li><li>using <code>echo hello &gt; file.txt</code></li><li>rename file</li><li>move file to other place</li><li><code>IN_ONESHOT</code> 使用觀察 <code>IN_IGNORED</code> 的狀況</li><li>若監視檔案移動到別的地方了，wd 中的 pathname 會不會更動？</li></ol><h2 id="19-5-佇列限制與-proc-檔案"><a href="#19-5-佇列限制與-proc-檔案" class="headerlink" title="19.5 佇列限制與 /proc 檔案"></a>19.5 佇列限制與 /proc 檔案</h2><p>在 linux kernel configuration 中要啟用 inotify，必須先開啟 menuconfig</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Symbol: INOTIFY_USER [=y]</span><br><span class="line">Type  : boolean Prompt:</span><br><span class="line">Inotify support for userspace</span><br><span class="line">  Defined at fs/notify/inotify/Kconfig:1</span><br><span class="line">  Location:</span><br><span class="line">    -&gt; File systems</span><br><span class="line">  Selects: ANON_INODES [=y] &amp;&amp; FSNOTIFY [=y]</span><br></pre></td></tr></table></figure><p>之後可以在 <code>/proc/sys/fs/inotify/</code> 中設定 inotify 機制的操作組態，此設定要為高權限使用者<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls -l /proc/sys/fs/inotify/</span><br><span class="line"></span><br><span class="line">-rw-r--r--1root0 Nov 21 14:58 max_queued_events</span><br><span class="line">-rw-r--r--1root0 Nov 21 14:58 max_user_instances</span><br><span class="line">-rw-r--r--1root0 Nov 21 14:58 max_user_watches</span><br></pre></td></tr></table></figure></p><ul><li><code>max_queued_events</code>: <font color="#FF0000">default 16384</font><ul><li>當呼叫 <code>inotify_init()</code> 時，這個值是設定新的 inotify instance 數目上限，若超過的話會產生 <code>IN_Q_OVERFLOW</code> 事件，wd return -1</li></ul></li><li><code>max_user_instances</code>: <font color="#FF0000">default 128</font><ul><li>真實使用者可以建立的 inotify instance 數目</li></ul></li><li><code>max_user_watches</code>: <font color="#FF0000">default 8192</font><ul><li>真實使用者可以建立的監看項目數量限制</li></ul></li><li>以上都可以進行設定</li></ul><h2 id="19-6-舊版本的系統監視檔案事件：dnotify"><a href="#19-6-舊版本的系統監視檔案事件：dnotify" class="headerlink" title="19.6 舊版本的系統監視檔案事件：dnotify"></a>19.6 舊版本的系統監視檔案事件：dnotify</h2><p>從 Linux kernel <code>v2.4</code> 之後支援，之後被 inotify 所取代，因為有許多限制：</p><ul><li>dnotify 是透過 signal 傳送事件通知，而 inotify 沒有使用訊號</li><li>dnotify 監視的單位是一個 <strong>目錄</strong> ，而 inotify 則可以用來監視檔案或目錄</li><li>為了監視目錄，dnotify 需要應用程式開啟那個目錄的 fd ，使用 file descriptor 會有兩個問題<ul><li>由於忙碌，所以包含那個目錄的檔案系統都不可以被卸載</li><li>每個目錄都需要 fd ，所以會消耗大量的檔案描述符，但 inotify 沒有使用，所以可以避免這個問題</li></ul></li><li>dnotify 事件資訊沒有 inotify 來得精準</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;inotify_event&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;		wd;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt;	mask;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt;	cookie;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;uint32_t&lt;/span&gt;	len;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;	name[];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="The Linux Programming Interface" scheme="https://m033010041.github.io/tags/The-Linux-Programming-Interface/"/>
    
      <category term="Linux" scheme="https://m033010041.github.io/tags/Linux/"/>
    
      <category term="讀書心得" scheme="https://m033010041.github.io/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>[讀書心得] The Linux Programming Interface 第 11 章：系統限制</title>
    <link href="https://m033010041.github.io/2018/10/03/TLPI-SysLimit/"/>
    <id>https://m033010041.github.io/2018/10/03/TLPI-SysLimit/</id>
    <published>2018-10-03T01:44:14.000Z</published>
    <updated>2018-11-21T16:42:04.111Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ getconf NAME_MAX ~/Desktop</span><br><span class="line">255</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>每個 Unix 系統對各種系統功能與資源受限，並提供(或是選擇不提供)由各種標準定義的選項，例如：</p><ul><li>一個行程能同時開啟多少個檔案？</li><li>系統是否支援即時訊號？</li><li>型別為 <code>int</code> 的變數可儲存的最大值是多少？</li><li>一個程式能有多大的參數清單？</li><li>路徑名稱的最大長度是多少？</li></ul><p>我們通常會制定一個應用程式的限制與選項(limits or options)， <strong>但會減少可攜性</strong> ，因為限制與選項會與 <strong>系統不同而隨之改變</strong> ，像是說：</p><ul><li>跨 unix 系統：隨著不同的 unix 系統會造成 <code>int</code> 可儲存的最大值不同。</li><li>在特地系統的執行期環境：應用程式可能是在 A 系統編譯，按對於 B 系統中有著不同的限制情形。</li><li>file system 的轉移：<ul><li>SystemV：檔名長度最多 14 位元組</li><li>BSD file system：檔名程度最多 255 位元組</li></ul></li></ul><h2 id="11-1-系統限制"><a href="#11-1-系統限制" class="headerlink" title="11.1 系統限制"></a>11.1 系統限制</h2><p>SUSv3 要求全部的系統，對於 SUSv3 指定的限制都要<strong>提供一個最小值</strong>，這樣就可以移植到遵循此標準的系統，通常會在 <code>&lt;limit.h&gt;</code> 常數中定義，命名原則使用前綴 <code>_POSIX_</code> 字串，而且<strong>通常</strong>包含 <code>_MAX</code> 字串，所以命名格式通常為 <code>_POSIX_XXX_MAX</code></p><blockquote><p>這邊其實很弔詭，其實命名 <strong>_MAX</strong> 但稱其名稱為最小值是一件很怪的事<br>當我們了解這個常數是用來定義某些資源或特性上限值的常數，此上限值必須有明確的最小值時，就可以清楚理解了。</p></blockquote><p>By the way: 在編譯的過程中遇到了一個問題，macos high sierra 升級到 macos mojave 之後執行 gcc -o … 會跳出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun</span><br></pre></td></tr></table></figure><p>此時的處理方式是透過 <a href="https://apple.stackexchange.com/questions/254380/macos-mojave-invalid-active-developer-path" target="_blank" rel="noopener">這個處理方式</a> 來解決，執行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure></p><p>在 mac 系統中</p><ul><li><code>limits.h</code> 放置於 <code>/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/limits.h</code></li><li><code>unistd.h</code> 放置於 <code>/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/unistd.h</code></li></ul><p>SUSv3 將其規範限制分成三類</p><ol><li>執行期恆定值(runtime invariant value)</li><li>路徑名稱變動值(pathname variable value)</li><li>執行期可增值(runtime increasable value)</li></ol><h3 id="執行期恆定值-runtime-invariant-value"><a href="#執行期恆定值-runtime-invariant-value" class="headerlink" title="執行期恆定值(runtime invariant value)"></a>執行期恆定值(runtime invariant value)</h3><h3 id="路徑名稱變動值-pathname-variable-value"><a href="#路徑名稱變動值-pathname-variable-value" class="headerlink" title="路徑名稱變動值(pathname variable value)"></a>路徑名稱變動值(pathname variable value)</h3><h3 id="執行期可增值-runtime-increasable-value"><a href="#執行期可增值-runtime-increasable-value" class="headerlink" title="執行期可增值(runtime increasable value)"></a>執行期可增值(runtime increasable value)</h3><ul><li>參數命名：於執行期時可用於 <code>sysconf()</code> 或是 <code>pathconf()</code> 以取得系統的限制值<ul><li><code>_SC_</code> 開頭的常數可用於 <code>sysconf()</code></li><li><code>_PC_</code> 開頭的常數可用於 <code>pathconf()</code> 或是 <code>fpathconf()</code></li></ul></li></ul><h3 id="從-shell-取得限制與選項：getconf"><a href="#從-shell-取得限制與選項：getconf" class="headerlink" title="從 shell 取得限制與選項：getconf"></a>從 shell 取得限制與選項：<code>getconf</code></h3><p>執行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ getconf variable-name [pathname]</span><br></pre></td></tr></table></figure></p><h2 id="11-2-在執行期取得系統限制與選項-sysconf"><a href="#11-2-在執行期取得系統限制與選項-sysconf" class="headerlink" title="11.2 在執行期取得系統限制與選項 sysconf()"></a>11.2 在執行期取得系統限制與選項 <code>sysconf()</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns value of limit specified by name,</span></span><br><span class="line"><span class="comment"> * or -1 if limit is indeterminate or an error occurred</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sysconf</span><span class="params">(<span class="keyword">int</span> name)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>參數 <code>name</code> 是定義於 <code>&lt;unistd.h&gt;</code> 的其中一個 <code>_SC_*</code> 常數</li><li>回傳內容即為限制值</li><li>若錯誤發生活是無法確定限制時則會回傳 -1，且 <strong>errno 非 0</strong> ，表示發生錯誤</li></ul><p>在 SUSv3 的規範之中，<em>sysconf()</em> 所傳回的限制值在呼叫的行程之生命週期內<strong>必須是個常數</strong></p><h2 id="11-3-在執行期取得檔案限制與選項-pathconf-fpathconf"><a href="#11-3-在執行期取得檔案限制與選項-pathconf-fpathconf" class="headerlink" title="11.3 在執行期取得檔案限制與選項 pathconf() / fpathconf()"></a>11.3 在執行期取得檔案限制與選項 <code>pathconf() / fpathconf()</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Both return value of limit specified by name,</span></span><br><span class="line"><span class="comment"> * or -1 if limit is indterminate or an error occurred</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">pathconf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fpathconf</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> name)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><code>pathconf()</code> 與 <code>fpathconf()</code> 不同之處就在於<ul><li><code>pathconf()</code> 輸入參數為路徑字串</li><li><code>fpathconf()</code> 是使用 file descriptor</li></ul></li><li>參數 <code>name</code> 是定義於 <code>&lt;unistd.h&gt;</code> 的其中一個 <code>_PC_*</code> 系列常數</li><li>與 <code>sysconf()</code> 相同地，回傳的結果我即為限制值，且可區分回傳的是限制值還是錯誤，也可以用 errno 分辨錯誤</li><li>與 <code>sysconf()</code> 不同的是：SUSv3 並不要求 <em>pathconf() / fpathconf()</em> 的回傳值必須在形成的生命週期內保持不變。例如，行程執行時， <strong>檔案系統可能會被卸載並以不同的性質重新裝載</strong></li></ul><h2 id="延伸：autoconf-automake-aclocal"><a href="#延伸：autoconf-automake-aclocal" class="headerlink" title="延伸：autoconf + automake + aclocal"></a>延伸：autoconf + automake + aclocal</h2><p>GNU Autoconf 是一個擴充工具，可以<strong>確定各種系統特性及限制的存在及設定</strong>，autoconf 可以基於所收集到的資訊而產生標頭檔，並將這些檔案 include 進 C 程式中。</p><h3 id="透過-autoconf-automake-aclocal-自動產生-Makefile"><a href="#透過-autoconf-automake-aclocal-自動產生-Makefile" class="headerlink" title="透過 autoconf + automake + aclocal 自動產生 Makefile"></a>透過 autoconf + automake + aclocal 自動產生 Makefile</h3><ul><li>首先要先安裝相關套件<br><code>brew install autoconf automake libtool</code></li><li><p>安裝完後就找一個 .c 檔試試看</p><ol><li>執行 <code>autoscan</code></li><li>會產生 <code>configure.scan</code></li><li><p>修改 <code>configure.scan</code> 後將其檔名修改成 <code>configure.in</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Process this file with autoconf to produce a con figure script.</span></span><br><span class="line"></span><br><span class="line">AC_INIT(src.c)</span><br><span class="line">AM_INIT_AUTOMAKE(src, 1.0)</span><br><span class="line"><span class="comment"># Checks for programs.</span></span><br><span class="line">AC_PROG_CC</span><br><span class="line"><span class="comment"># Checks for libraries.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Checks for header files.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Checks for typedefs, structures, and compiler ch aracteristics.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Checks for library functions.</span></span><br><span class="line"></span><br><span class="line">AC_OUTPUT(Makefile)</span><br></pre></td></tr></table></figure></li><li><p>執行 <code>aclocal</code></p></li><li>執行 <code>autoconf</code></li><li>應該會產生 <code>aclocal.m4 configure configure.in src.c</code></li><li><p>編輯 <code>Makefile.am</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AUTOMAKE_OPTIONS= foreign</span><br><span class="line"></span><br><span class="line">bin_PROGRAMS= src</span><br><span class="line"></span><br><span class="line">hello_SOURCES= src.c</span><br></pre></td></tr></table></figure></li><li><p>執行 <code>automake --add-missing</code></p></li><li>執行 <code>./configure</code></li><li>應該會產生 Makefile 等檔案</li><li>執行 <code>make / make install / make dist</code> 等即可</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ getconf NAME_MAX ~/Desktop&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;255&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="The Linux Programming Interface" scheme="https://m033010041.github.io/tags/The-Linux-Programming-Interface/"/>
    
      <category term="Linux" scheme="https://m033010041.github.io/tags/Linux/"/>
    
      <category term="讀書心得" scheme="https://m033010041.github.io/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>2017 暑期系統軟體課程台北場(課前測驗題)</title>
    <link href="https://m033010041.github.io/2017/07/17/2017SysProg/"/>
    <id>https://m033010041.github.io/2017/07/17/2017SysProg/</id>
    <published>2017-07-17T05:33:42.000Z</published>
    <updated>2018-11-21T17:19:35.372Z</updated>
    
    <content type="html"><![CDATA[<p>上班之餘，看到了 jserv 的軟體課程，花了一點時間看看。以下是我寫程式途中所的開發筆記與成果</p><p>題目詳細內容：<a href="https://hackmd.io/s/B1wb8CyHb" target="_blank" rel="noopener">課前測驗題</a><br>程式內容(Github)：<a href="https://github.com/m033010041/2017_sysprog" target="_blank" rel="noopener">請點我</a></p><a id="more"></a><h2 id="Question-01"><a href="#Question-01" class="headerlink" title="Question 01"></a>Question 01</h2><p>以下是題目給予的程式碼：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="keyword">uint32_t</span> func(<span class="keyword">uint32_t</span> x) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> n = x;</span><br><span class="line">    n = ((n &amp; <span class="number">0xffff0000</span>) &gt;&gt; <span class="number">16</span>) | ((n &amp; <span class="number">0x0000ffff</span>) &lt;&lt; <span class="number">16</span>);</span><br><span class="line">    n = ((n &amp; <span class="number">0xff00ff00</span>) &gt;&gt;  <span class="number">8</span>) | ((n &amp; <span class="number">0x00ff00ff</span>) &lt;&lt;  <span class="number">8</span>);</span><br><span class="line">    n = ((n &amp; <span class="number">0xf0f0f0f0</span>) &gt;&gt;  <span class="number">4</span>) | ((n &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt;  <span class="number">4</span>);</span><br><span class="line">    n = ((n &amp; <span class="number">0xcccccccc</span>) &gt;&gt;  <span class="number">2</span>) | ((n &amp; <span class="number">0x33333333</span>) &lt;&lt;  <span class="number">2</span>);</span><br><span class="line">    n = ((n &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt;  <span class="number">1</span>) | ((n &amp; <span class="number">0x55555555</span>) &lt;&lt;  <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="我的解答："><a href="#我的解答：" class="headerlink" title="我的解答："></a>我的解答：</h3><p>仔細觀察後可以發現這個 function 會將數值 x 的 bit 從大範圍至小範圍進行交換，這種算是有效率的 bit reverse algorithm</p><p>bit reverse algorithm 最常用在快速傅立葉轉換 (FFT) 中，裡面有一個重要的步驟，就是透過 butterfly 網路進行頻率降取樣 (decimation-in-frequency) 的時候，需要變換輸入點的編號 (order)</p><p><img src="https://i.imgur.com/KFqpUCV.gif" alt="8 point FFT"></p><p>以下是透過 for/while 所改寫的 bit reverse function</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="keyword">uint32_t</span> func1(<span class="keyword">uint32_t</span> x) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> r = x &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> shift = <span class="keyword">sizeof</span>(x) * <span class="number">8</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(x = x &gt;&gt; <span class="number">1</span>; x; x&gt;&gt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r = r &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        r = r | (x &amp; <span class="number">1</span>);</span><br><span class="line">        shift--;</span><br><span class="line">    &#125;</span><br><span class="line">    r &lt;&lt;= shift;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這個方式就是先觀察 x 是否為 0 ，若不為 0 就進行右移，存入 r 中後進行左移，當 x = 0 時看還剩下多少需要左移的數量一次移完，這種寫法的好處是我 16 bit 的做法只要把 input/output 的宣告改掉即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="keyword">uint16_t</span> func2(<span class="keyword">uint16_t</span> x) &#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> r = x &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">uint16_t</span> shift = <span class="keyword">sizeof</span>(x) * <span class="number">8</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(x = x &gt;&gt; <span class="number">1</span>; x; x&gt;&gt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        r = r &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        r = r | (x &amp; <span class="number">1</span>);</span><br><span class="line">        shift--;</span><br><span class="line">    &#125;</span><br><span class="line">    r &lt;&lt;= shift;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2#.E7.AE.97.E6.B3.95.E5.AE.9E.E7.8E.B0" target="_blank" rel="noopener">快速傅立葉轉換：bit reverse</a><br><a href="http://www.idi.ntnu.no/~elster/pubs/elster-bit-rev-1989.pdf" target="_blank" rel="noopener">fast bit reversal algorithm</a></p><h2 id="Question-02"><a href="#Question-02" class="headerlink" title="Question 02"></a>Question 02</h2><p>乘法器實作，其實看的範例的乘法器，那個 half_add()，似乎是全加器欸？</p><p>因為 <code>return half_add(sum, carry);</code> 補進去之後就變成了 ripple-carry adder 了</p><p>剛開始我的想法是，給定一個被乘數 a 和乘數 b，表示 a 會 <strong>被加 b 次</strong> ，由這個簡單的想法我可以把 code 寫成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> mul32(<span class="keyword">uint32_t</span> a, <span class="keyword">uint32_t</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> result=<span class="number">0</span>, i;</span><br><span class="line">    <span class="keyword">uint32_t</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=b; b; b&gt;&gt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)  <span class="comment">//if bit i is 1</span></span><br><span class="line">            result = half_add(result, (a&lt;&lt;j));</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但這樣似乎不符合 recurive 的規定，因此修改了程式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> mul32_recursive(<span class="keyword">uint32_t</span> a, <span class="keyword">uint32_t</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> half_add(((b&amp;<span class="number">1</span>)?a:<span class="number">0</span>), (mul32_recursive(a, b&gt;&gt;<span class="number">1</span>)&lt;&lt; <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這樣就大功告成囉～</p><h2 id="Question-05"><a href="#Question-05" class="headerlink" title="Question 05"></a>Question 05</h2><p>討論以下程式碼<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        fork();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   wait(<span class="literal">NULL</span>); wait(<span class="literal">NULL</span>); wait(<span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果將這個程式丟進 linux 執行後我們可以得到輸出的數值為 24，這個到底是什麼原因呢？理論上，<code>fork()</code> 執行 N 次，所產生的 process 數目應為 2^N^ - 1 個，因此此程式執行完後總共有 8 個 process (包含 main 程序)。</p><p>接下來我們討論 printf 的處理方式，printf 主要會 call <code>fprintf(stdout, &quot;...&quot;);</code></p><p>但是在 <a href="http://fanli7.net/a/bianchengyuyan/_NET/20120831/215063.html" target="_blank" rel="noopener">這篇文章</a> 中提到，<code>fork()</code> 執行時會先把資料丟到 <code>stdout</code> 的緩衝區，但是不會立即的觸發輸出，這個可能就是為什麼會輸出 24 的原因了</p><p>理論上所顯示的數目為 14 個，由下圖的分析可得知</p><p><img src="https://i.imgur.com/rpUw9JB.png" alt=""></p><p>因為 <code>fork()</code> 之後子程序會保留當下父程序的狀態，因此可以獲得 14 個 “-“ 符號，但是由於不會立即觸發 <code>stdout</code> 緩衝區，因此在    <code>fork()</code> 的當下其實 <code>stdout</code> 緩衝區的內容也一併被複製到子程序了，如下圖</p><p><img src="https://i.imgur.com/936j2Od.png" alt=""></p><p>因此輸出時會得到 24 個 “-“ 符號</p><p>喔對了，忘了補上如果直接觸發 <code>stdout</code> 緩衝區，其實只要透過 <code>&#39;\n&#39;</code> 這個字元就可以直接觸發 <code>stdout</code>，將結果直接印出來，我們只要修改 printf 即可獲得</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        fork();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-\n"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   wait(<span class="literal">NULL</span>); wait(<span class="literal">NULL</span>); wait(<span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這樣輸出就會變成是 14 個 “-“ 符號囉～</p><h3 id="參考資料-1"><a href="#參考資料-1" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="http://fanli7.net/a/bianchengyuyan/_NET/20120831/215063.html" target="_blank" rel="noopener">linux中fork（）函數詳解（原創！！實例講解）（轉載）</a></p><h2 id="Release-Note"><a href="#Release-Note" class="headerlink" title="Release Note"></a>Release Note</h2><p>三四題之後會在此文章補上<br>Q5 補上觸發緩衝區程式碼</p><p>comment</p><blockquote><p>This is Gugeegee.[name=劉安庭][color=#def29d]<br>[time=Mon, Jul 17, 2017 11:45 AM]<br>GitHub: <a href="https://github.com/m033010041/2017_sysprog" target="_blank" rel="noopener">https://github.com/m033010041/2017_sysprog</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上班之餘，看到了 jserv 的軟體課程，花了一點時間看看。以下是我寫程式途中所的開發筆記與成果&lt;/p&gt;
&lt;p&gt;題目詳細內容：&lt;a href=&quot;https://hackmd.io/s/B1wb8CyHb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;課前測驗題&lt;/a&gt;&lt;br&gt;程式內容(Github)：&lt;a href=&quot;https://github.com/m033010041/2017_sysprog&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;請點我&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="OS" scheme="https://m033010041.github.io/tags/OS/"/>
    
      <category term="system prog" scheme="https://m033010041.github.io/tags/system-prog/"/>
    
  </entry>
  
</feed>
